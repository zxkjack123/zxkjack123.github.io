<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[新标日初级上第一课学习]]></title>
      <url>/Japanese/text-book-standard-1st/</url>
      <content type="html"><![CDATA[<h2 id="基本课文"><a href="#基本课文" class="headerlink" title="基本课文"></a>基本课文</h2><ol>
<li>李さんは中国人です。</li>
<li>森さんは学生ではありません。</li>
<li>林さんは日本人ですか。</li>
<li>李さんはJC企画の社員です。</li>
</ol>
<ul>
<li>私は李です。小野さんですか。　ーはい、そうです。小野です。</li>
<li>森さんは学生ですか。　ーいいえ、学生ではありません。会社員です。</li>
<li>吉田さんですか。　ーいいえ、ちがいます。森です。</li>
<li>李さんはJC企画の社員ですか。　ーはい、そうです。</li>
</ul>
<h2 id="应用课文"><a href="#应用课文" class="headerlink" title="应用课文"></a>应用课文</h2><h3 id="出迎え"><a href="#出迎え" class="headerlink" title="出迎え"></a>出迎え</h3><p>飞机准点到达成田机场。小野绿和同时森健太郎在候机大厅等着小李。小李办完入境手续，到大厅后，看到写着“李秀麗様”字样的牌子。</p>
<p>(小李朝牌子的方向走去)</p>
<p>李：JC企画の小野さんですか。</p>
<p>小野：はい、小野です。李秀麗さんですか。</p>
<p>李：はい、李秀麗です。はじめまして。どうぞよろしくお願いします。</p>
<p>小野：はじめまして、小野緑です。</p>
<p>(森在一旁插话)</p>
<p>森：李さん、こんにちは。</p>
<p>李：吉田さんですか。</p>
<p>森：いいえ、わたしは吉田じゃありません。森です。</p>
<p>李：あっ、森さんですか。どうもすみません。</p>
<p>森：いいえ、どうぞよろしく。</p>
<p>李：李秀麗です。こちらこそ、よろしくお願いします。</p>
<h2 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h2><p>这一课的语法内容是名词谓语句。名词谓语句，顾名思义，就是名词做谓语的句子。句子结构分三种：</p>
<ul>
<li>[名1]は [名2]です</li>
<li>[名1]は [名2]ではありません</li>
<li>[名1]は [名2]ですか</li>
</ul>
<p>这是判定句。<strong>~は</strong>是主语部分（注意，主语成分包含は这个助词),<strong>~です</strong>是谓语部分。<strong>です</strong>是判定助动词。</p>
<p>日语语法与现代汉语差别很大，不能用现代这一点与古汉语中的判断句比较类似。现代汉语中的谓语是肯定包含动词的。而日语的谓语则可以由名词，形容词和动词组成。</p>
<p>这个判断句的的结构其实和古汉语判断句的<strong>~者，~也</strong>比较相似：</p>
<ul>
<li>陈胜<strong>者</strong>，阳城人<strong>也</strong>。</li>
<li>陈胜<strong>は</strong>，阳城人<strong>です</strong>。</li>
</ul>
<p>与<strong>者</strong>，<strong>也</strong>类似，<strong>は</strong>和<strong>です</strong>本身没有实际意义，他们的功能是像标签一样提示这部分内容的成分。<strong>は</strong>是告诉我们：这是主题。<strong>です</strong>是告诉我们：这是谓语。</p>
<p><strong>か</strong>同理，用于表示这是一个疑问句。</p>
<p>注意：这里把日语名词谓语句与古汉语的判断句类比，只是为了方便理解。在日语学习的过程中，最好不要把日语的句子先映射到中文再进行理解。日语和汉语一样，都是可以直接反应现实或抽象的事物的。学习日语时应该训练自己把日语内容直接映射到世界中的事物，而不是先映射到中文。</p>
<p><a href="https://zxkjack123.github.io/Japanese/text-book-list/">返回学习笔记列表</a></p>
]]></content>
      
        <categories>
            
            <category> Japanese </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Japanese </tag>
            
            <tag> 日语 </tag>
            
            <tag> 日本語 </tag>
            
            <tag> 课文 </tag>
            
            <tag> 初级上 </tag>
            
            <tag> 新标日 </tag>
            
            <tag> 第一课 </tag>
            
            <tag> 名词谓语句 </tag>
            
            <tag> 判断句 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[日语学习笔记列表]]></title>
      <url>/Japanese/text-book-list/</url>
      <content type="html"><![CDATA[<h2 id="新标日"><a href="#新标日" class="headerlink" title="新标日"></a>新标日</h2><h3 id="初级上"><a href="#初级上" class="headerlink" title="初级上"></a>初级上</h3><ol>
<li><a href="https://zxkjack123.github.io/Japanese/text-book-standard-1st/">第一课学习笔记</a></li>
</ol>
<h3 id="初级下"><a href="#初级下" class="headerlink" title="初级下"></a>初级下</h3><p>つづく</p>
]]></content>
      
        <categories>
            
            <category> Japanese </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Japanese </tag>
            
            <tag> 日语 </tag>
            
            <tag> 日本語 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 列表 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Thunderbird接收常用邮箱设置]]></title>
      <url>/ubuntu/thunderbird-set/</url>
      <content type="html"><![CDATA[<h2 id="163邮箱"><a href="#163邮箱" class="headerlink" title="163邮箱"></a>163邮箱</h2><p>Thunderbird接收163免费邮箱设置：</p>
<table>
<thead>
<tr>
<th style="text-align:center">服务器名称</th>
<th style="text-align:center">服务器地址</th>
<th style="text-align:center">SSL协议端口号</th>
<th style="text-align:center">非SSL协议端口号</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IMAP</td>
<td style="text-align:center">imap.163.com</td>
<td style="text-align:center">993</td>
<td style="text-align:center">143</td>
</tr>
<tr>
<td style="text-align:center">SMTP</td>
<td style="text-align:center">smtp.163.com</td>
<td style="text-align:center">465/994</td>
<td style="text-align:center">25</td>
</tr>
<tr>
<td style="text-align:center">POP3</td>
<td style="text-align:center">pop.163.com</td>
<td style="text-align:center">995</td>
<td style="text-align:center">110</td>
</tr>
</tbody>
</table>
<p>163免费邮客户端设置的POP3、SMTP、IMAP设置<a href="http://help.163.com/09/1223/14/5R7P3QI100753VB8.html" target="_blank" rel="noopener">参考链接</a>。</p>
<p><strong>注意</strong>：SMTP设置推荐为</p>
<ul>
<li>Sever Name: smtp.163.com</li>
<li>Port: 25</li>
<li>Connection security: None</li>
<li>Authentication method: Password, transmitted insecurely</li>
<li>User Name: xxxxxx@163.com</li>
</ul>
<p>经过本人实践检验，上面的设置可以接收和发送邮件。而SMTP使用其他设置时就没法发邮件了。</p>
<h2 id="中科院邮箱"><a href="#中科院邮箱" class="headerlink" title="中科院邮箱"></a>中科院邮箱</h2><p>Thunderbird接收中科院系统邮箱设置：</p>
<table>
<thead>
<tr>
<th style="text-align:center">服务器名称</th>
<th style="text-align:center">服务器地址</th>
<th style="text-align:center">安全链接</th>
<th style="text-align:center">端口</th>
<th style="text-align:center">验证方式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IMAP</td>
<td style="text-align:center">imap.cstnet.cn</td>
<td style="text-align:center">None</td>
<td style="text-align:center">143</td>
<td style="text-align:center">用户名与密码</td>
</tr>
<tr>
<td style="text-align:center">SMTP</td>
<td style="text-align:center">smtp.cstnet.cn</td>
<td style="text-align:center">None</td>
<td style="text-align:center">25</td>
<td style="text-align:center">用户名与密码</td>
</tr>
</tbody>
</table>
<p><a href="http://help.cstnet.cn/changjianwenti/youjianshoufa/Mozilla%20Thunderbird%20imap.html" target="_blank" rel="noopener">参考链接</a></p>
<h2 id="中科大学生邮箱"><a href="#中科大学生邮箱" class="headerlink" title="中科大学生邮箱"></a>中科大学生邮箱</h2><p>Thunderbird接收中科大学生邮箱设置：</p>
<table>
<thead>
<tr>
<th style="text-align:center">服务器名称</th>
<th style="text-align:center">服务器地址</th>
<th style="text-align:center">加密方式</th>
<th style="text-align:center">端口</th>
<th style="text-align:center">Clear text</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IMAP</td>
<td style="text-align:center">mail.ustc.edu.cn</td>
<td style="text-align:center">SSL</td>
<td style="text-align:center">993</td>
<td style="text-align:center">143</td>
</tr>
<tr>
<td style="text-align:center">SMTP</td>
<td style="text-align:center">mail.ustc.edu.cn</td>
<td style="text-align:center">SSL</td>
<td style="text-align:center">465</td>
<td style="text-align:center">25</td>
</tr>
<tr>
<td style="text-align:center">POP</td>
<td style="text-align:center">mail.ustc.edu.cn</td>
<td style="text-align:center">SSL</td>
<td style="text-align:center">995</td>
<td style="text-align:center">110</td>
</tr>
</tbody>
</table>
<p><a href="http://mail.ustc.edu.cn/coremail/help/index.jsp" target="_blank" rel="noopener">参考链接</a></p>
]]></content>
      
        <categories>
            
            <category> ubuntu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> thunderbird </tag>
            
            <tag> email </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[OpenMC第一个例子]]></title>
      <url>/neutronics/openmc-first-example/</url>
      <content type="html"><![CDATA[<p>浏览过一遍OpenMC的<a href="http://openmc.readthedocs.io/en/stable/usersguide/index.html" target="_blank" rel="noopener">User Guide</a>之后，对OpenMC的使用有了大致的初步了解。</p>
<p>和其他蒙卡程序类似，OpenMC也是需要定义几何，材料，源和tally以及其他信息。OpenMC用不同的xml文件来存放不同的信息。</p>
<p>OpenMC有一个鲜明的特性：Python API，OpenMC相关的所有内容都有Python API，这样我们可以直接通过python脚步来写相应的信息，然后直接使用导出函数转化成xml文件。这个API的存在对比较小规模的问题，或者几何不是非常复杂的问题是比较方便的。另外，数据后处理部分，OpenMC也有接口，画图和数据处理都很容易。</p>
<p>本文将通过一个非常简单的小例子来进行一次完整的OpenMC准备和计算流程。</p>
<h2 id="准备核数据"><a href="#准备核数据" class="headerlink" title="准备核数据"></a>准备核数据</h2><p>OpenMC计算时，会从<code>openmc.Materials</code>或者<code>materials.xml</code>中寻找材料数据库的位置，可以通过这两个方式定义材料库的位置。</p>
<p>不过如果我们只使用固定的材料库的话，每次都要特别制定材料数据库就太麻烦了。可以通过把材料数据库的路径添加到系统变量<code>OPENMC_CROSS_SECTIONS</code>中去。</p>
<h3 id="获取数据库"><a href="#获取数据库" class="headerlink" title="获取数据库"></a>获取数据库</h3><p><a href="http://openmc.readthedocs.io/en/stable/usersguide/cross_sections.html" target="_blank" rel="noopener">这里</a>介绍了获取不同数据库的方法。这里我为了简便，使用最简单的NNDC的数据库。根据文档，我需要使用openmc-get-nndc-data这个脚本。</p>
<p>因为这个数据库完全是为OpenMC计算任务而存在，所以我把这个数据库放在<code>$HOME/opt/OpenMC/NNDC</code>下。</p>
<pre><code class="bash">$ cd $HOME/opt/OpenMC
$ mkdir NNDC
$ cd NNDC
$ openmc-get-nndc-data
</code></pre>
<h3 id="添加路径"><a href="#添加路径" class="headerlink" title="添加路径"></a>添加路径</h3><p>然后把这个<code>OPENMC_CROSS_SECTIONS</code>的路径设为这个并添加到<code>$HOME/.bashrc</code>中去。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>为了简单，这里打算使用一个半径为10里面的球，这个球材质为密度为1.0的水，球外侧区域不考虑。</p>
<p>中子源就设为在原点的各项同性的1MeV的点源。 </p>
<h2 id="Python-API文件"><a href="#Python-API文件" class="headerlink" title="Python API文件"></a>Python API文件</h2><pre><code class="python"># input.py
import openmc

# materials
materials = openmc.Materials()
water = openmc.Material()
water.add_element(&#39;H&#39;, 0.667, &#39;ao&#39;)
water.add_element(&#39;O&#39;, 0.334, percent_type=&#39;ao&#39;)
water.set_density(&#39;g/cm3&#39;, 1.0) 
materials.append(water)
materials.export_to_xml()

# geometry - surfaces
sphere = openmc.Sphere(R=10.0)
sphere.boundary_type = &#39;vacuum&#39;
inside_sphere = -sphere
outside_sphere = +sphere
# geometry cells
universe = openmc.Universe()
moderator = openmc.Cell(fill=water, region=inside_sphere)
universe.add_cell(moderator)
geometry = openmc.Geometry(universe)
geometry.export_to_xml(path=&#39;geometry.xml&#39;) 

# run mode
settings = openmc.Settings()
settings.run_mode = &#39;fixed source&#39;
settings.particles = 10000
settings.batches = 10
# output
settings.output = {&#39;tallies&#39;:True, &#39;summary&#39;:True}
# source distribution
source = openmc.Source()
source.space = openmc.stats.Point(xyz=(0., 0., 0.))
source.angle = openmc.stats.Isotropic()
source.energy = openmc.stats.Discrete([10.0e6], [1.0])
settings.source = source
settings.export_to_xml(path=&#39;settings.xml&#39;)

# tallies
cell_filter = openmc.CellFilter([moderator])
tally1 = openmc.Tally()
tally1.scores = [&#39;flux&#39;]
tally1.filters.append(cell_filter)
tallies = openmc.Tallies()
tallies.add_tally(tally1)
tallies.export_to_xml()

# plot
plot1 = openmc.Plot()
plot1.basis = &#39;xz&#39;
plot1.origin = (0, 0, 0)
plot1.width = (20, 20)
plot1.pixels = (400, 400)
plot1.color_by = &#39;material&#39;
plots =openmc.Plots()
plots.add_plot(plot1)
plots.export_to_xml()

# run
openmc.run()
openmc.plot_geometry(output=True, openmc_exec=&#39;openmc&#39;, cwd=&#39;.&#39;)
</code></pre>
<h2 id="生成的几何图像"><a href="#生成的几何图像" class="headerlink" title="生成的几何图像"></a>生成的几何图像</h2><p>上面的脚本会生成一个叫做plot_10000.ppm，用convert命令转化为png格式。</p>
<pre><code class="bash">$ convert plot_10000.ppm plot_10000.png
</code></pre>
<p>可以看到生成的几何图像的样子：<br><img src="https://i.imgur.com/xMIVxAh.png" alt="图像"></p>
]]></content>
      
        <categories>
            
            <category> neutronics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenMC </tag>
            
            <tag> example </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[中子输运相关软件]]></title>
      <url>/neutronics/neutron-transport-code/</url>
      <content type="html"><![CDATA[<p>我的专业是核能科学与工程，这个专业做实验代价很高，而且现在也有一些比较可靠的模拟计算工具。因此很多时候都要用到模拟计算，不论是单独计算还是作为实验的预分析。</p>
<p>很多模拟计算的核心，是计算中子通量。这个需要进行中子输运计算。中子输运计算分两类，一类是确定论的计算，就是通过解方程的方法计算，另一类是蒙特卡罗方法计算。</p>
<p>两种计算方法各有优缺点。我接触比较多的聚变领域，由于几何模型非常复杂，用确定论方法计算不够准确，一般都是用蒙特卡罗方法计算。</p>
<p>蒙特卡罗中子输运软件中，最出名的就是MCNP了。不过这个软件对中国是封锁的，中国人是没法使用的。（当然也有特例，原子能院可以合法使用MNCP4C，不过MCNP现在的版本是MCNP6了，4C是非常旧的版本了）</p>
<p>我作为一个平时主要做核分析模拟计算的研究生，非常尴尬，我的博士研究可以受限制很严重。如果不能用其他的可靠的工具代替MCNP，现在我的方向就是一条没有前途的路。国内的确需要这方面的人来做相应的工作，但这些工作难发文章，难以升迁。我现在是博士第三年，现在改变自己的课题或是方向，代价太高。现在在脚镣下跳舞是不得已而为之。但当我博士毕业之后，如果还继续读个博后之类的继续走科研道路的话，绝对不能再在这条路上一条道走到黑了。</p>
<p>那么，我就需要了解一下现在的一些中子输运软件了。Quora上有一个<a href="https://www.quora.com/What-are-some-nuclear-reactor-simulation-codes" target="_blank" rel="noopener">问题</a>已经给出了非常简洁明了的答案。搬运过来并做一些补充：</p>
<ul>
<li>Probabilistic codes<ul>
<li><a href="https://github.com/mit-crpg/openmc" target="_blank" rel="noopener">OpenMC</a> - An MIT developed open source Monte Carlo code. It is a constructive solid geometry, continuous-energy transport code that uses HDF5 format cross sections.</li>
<li><a href="https://mcnp.lanl.gov/" target="_blank" rel="noopener">MCNP</a> - A LANL developed Monte Carlo code for general radiation transport</li>
<li><a href="http://www.oecd-nea.org/tools/abstract/detail/ccc-0436/" target="_blank" rel="noopener">KENO</a> - An ORNL developed Monte Carlo code for criticality analysis</li>
<li><a href="http://www.answerssoftwareservice.com/mcbend/" target="_blank" rel="noopener">MCBEND</a> - An ANSWERS Software Service developed Monte Carlo code for general radiation transport</li>
<li><a href="http://montecarlo.vtt.fi/" target="_blank" rel="noopener">Serpent</a> - A Finnish developed Monte Carlo neutron transport code</li>
<li><a href="http://www.oecd-nea.org/tools/abstract/detail/nea-1716/" target="_blank" rel="noopener">TRIPOLI</a> - 3D general purpose continuous energy Monte Carlo Transport code developed at CEA, France. TRIPOLI-4 solves fixed source as well as eigenvalue problems.</li>
</ul>
</li>
<li>Deterministic codes<ul>
<li><a href="https://www.vareximaging.com/products/attila-software" target="_blank" rel="noopener">Attila</a> - A commercial transport code</li>
<li><a href="http://www.polymtl.ca/merlin/downloads/IGE294.pdf" target="_blank" rel="noopener">DRAGON</a> - An open-source lattice physics code</li>
<li>PHOENIX/ANC - A proprietary lattice-physics and global diffusion code suite from Westinghouse Electric</li>
<li>PARTISN - A LANL developed transport code based on the discrete ordinates method</li>
<li>NEWT - An ORNL developed 2-D SN code</li>
<li>DIF3D/VARIANT - An Argonne National Laboratory developed 3-D code originally developed for fast reactors</li>
<li>DENOVO - A massively parallel transport code under development by ORNL</li>
<li>DANTSYS</li>
<li>RAMA - A proprietary 3D method of characteristics code with arbitrary geometry modeling, developed for EPRI byTransWare Enterprises Inc.</li>
<li>RAPTOR-M3G - A proprietary parallel radiation transport code developed by Westinghouse Electric Company</li>
<li>OpenMOC - An MIT developed open source parallel method of characteristics code</li>
<li>MPACT - A parallel 3D method of characteristics code under development by the University of Michigan</li>
<li>DORT - Discrete Ordinates Transport</li>
</ul>
</li>
</ul>
<p>替代软件不一定要计算最准确，但一定要是中国人可以（免费下载后者收费购买）获取的软件。</p>
<p>MCNP是肯定没戏的了，对中国人限制摆在这里。</p>
<p>目前SERPENT的<a href="http://www.oecd-nea.org/dbprog/pretlo.cgi?country=CHINA&amp;submit=Display" target="_blank" rel="noopener">中国获取单位</a>中显示有北京和程度的几家单位，可以尝试通过这个渠道获取。</p>
<p>另外，OpenMC是开源软件，现在还在开发完善过程中。<a href="https://www.sciencedirect.com/science/article/pii/S030645491400379X?via%3Dihub" target="_blank" rel="noopener">这篇文章</a>介绍了OpenMC的总体情况</p>
<ol>
<li>现在只支持中子输运计算，还不支持光子输运计算。</li>
<li>现在只支持固定源和k-value计算模式，不支持次临界源计算</li>
<li>现在只支持2阶曲面，不支持4阶曲面（聚变需要4阶曲面）</li>
</ol>
<p>但是OpenMC还是在不断更新发展中，而且是开源的，这就意味着我可以在之后自己加入这些所需要的功能。因此，对于我而言，学习OpenMC都是一个不错的选择，加入OpenMC的开发过程做一些贡献更是对我个人专业能力的一个非常好的锻炼。</p>
]]></content>
      
        <categories>
            
            <category> neutronics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> neutron transport </tag>
            
            <tag> neutron </tag>
            
            <tag> code </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用PyNE进行基于网格的计算停机计量的例子]]></title>
      <url>/neutronics/sample-trelis-dagmc-pyne-r2s-workflow/</url>
      <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本篇文章使用例子来说明使用PyNE来进行基于网格的计算停机剂量率的流程。</p>
<p>本流程需要提前安装Trelis, DAGMC, ALARA和PyNE。<br>DAGMC的安装可以参考<a href="https://zxkjack123.github.io/neutronics/dagmc-install/">这里</a>， PyNE的安装可以参考<a href="https://zxkjack123.github.io/neutronics/pyne-developer-install/">这里</a>。ALARA的安装可以参考<a href="https://zxkjack123.github.io/neutronics/alara-install/">这里</a>。</p>
<h2 id="例子的重要性"><a href="#例子的重要性" class="headerlink" title="例子的重要性"></a>例子的重要性</h2><p>使用的工具功能越多，那么使用起来一般就越复杂，新手就越难上手，新手总会在各种环节出现各种开发者意想不到的困难。即便软件官网上介绍了软件的各个工具的使用方法，但如果没有一个生动的例子来把这些应用工具的使用方法串起来的话，还是非常难的。</p>
<p>我自己作为一个PyNE系统的使用者，现在也参与了其中的部分开发工作，对此深有体会。对于新手的教学，告诉他们这个软件的各种功能是远远不够的，必须辅以实例，手把手的教会他们怎么用这个功能。用例子来说明这些问题是比较容易让新手接受的。我作为一个PyNE的使用者，也是一个新手。</p>
<p>这篇文章介绍了我如何从Trelis开始，一步一步实现计算一个简单模型的停机计量的过程的。</p>
<h2 id="例题描述"><a href="#例题描述" class="headerlink" title="例题描述"></a>例题描述</h2><p>现有如下形状的几何体：<br><img src="https://i.imgur.com/jvGtmPP.png" alt="test_case1"><br>图中每个小快代表着$ 10 \times 10 \times 10 \, \mathrm{cm}^3$的立方体。简单起见，我们把栅元1和3的材料设为密度为$1.0 \, \mathrm{g/cm^3}$的水(Water)，栅元2的材料设为密度为$7.8 \, \mathrm{g/cm^3}$的钢(Steel)。除了这几个栅元外其它区域都是真空。栅元1的正中心有一个点中子源，各项同性的发射能量为14 MeV的中子。</p>
<p>让点中子源以$10^{10}$个中子每秒的中子发射率辐照这几个栅元1年，然后停止辐照，考察停止辐照后1小时的栅元1, 2, 3的停机剂量率。</p>
<h2 id="输入文件准备"><a href="#输入文件准备" class="headerlink" title="输入文件准备"></a>输入文件准备</h2><p>要进行蒙特卡罗输运计算，我们需要提供以下信息：</p>
<ol>
<li>几何信息，包括栅元和曲面。</li>
<li>材料信息。每个区域（栅元）是什么材料（材料的组成份额）</li>
<li>中子源信息。</li>
<li>Tally信息。想统计的东西</li>
<li>其他信息。如截断卡，权重及权窗，计算终止条件等。</li>
</ol>
<p>与普通MCNP计算不同，使用DAGMC计算时这些信息并不是全部都由一个输入文件提供，而是分别通过不同的文件提供。一个加载了几何和材料信息的h5m文件提供几何和材料信息。而其他信息则通过另一个input文本文件提供。</p>
<h3 id="Trelis建模"><a href="#Trelis建模" class="headerlink" title="Trelis建模"></a>Trelis建模</h3><h4 id="几何体的建立"><a href="#几何体的建立" class="headerlink" title="几何体的建立"></a>几何体的建立</h4><p>使用Trelis建立3个立方体，并在立方体外围设置一个graveyard区域，所有到达graveyard区域的中子将被杀死。graveyard的设置可以参考DAGMC关于<a href="https://svalinn.github.io/DAGMC/usersguide/codes/dag-mcnp.html?highlight=graveyard" target="_blank" rel="noopener">graveyard的官方说明</a>。<br><img src="https://i.imgur.com/WLozRdH.png" alt="test_case1_model"><br>上图所示的三个小立方体块而就是我们建立的几个栅元，外面一个稍大的立方体薄壳就是我们想要的graveyard。<br>几何体分别标记为：</p>
<ol>
<li>蓝色小立方体，cell 1， trelis vol id: 1, 材料为密度为1的水，材料号设定为1</li>
<li>黄色小立方体，cell 2, trelis vol id: 2, 材料为密度为7.8的铁，材料号设定为2</li>
<li>红色小立方体块，cell 3, trelis vol id: 3， 材料为密度为1的水，材料号设定为1</li>
<li>黄色大立方体薄壳，graveyard, trelis vol id: 8</li>
</ol>
<h4 id="分组并赋材料"><a href="#分组并赋材料" class="headerlink" title="分组并赋材料"></a>分组并赋材料</h4><p>几何体设置好了之后，对这几个栅元进行分组并赋材料。<br>在trelis界面输入下面命令：</p>
<pre><code>trelis&gt; group &quot;mat:Water/rho:1.0&quot; add vol 1 3
trelis&gt; group &quot;mat:Steel/rho:7.8&quot; add vol 2
</code></pre><p><strong>备注1</strong>：’trelis&gt;’代表该命令是在trelis窗口中执行。<br><strong>备注2</strong>：这里使用的材料名必须在PyNE的材料库中存在才可以。可以使用</p>
<pre><code class="bash">
$ strings $HOME/.local/lib/python2.7/site-packages/pyne/nuc_data.h5 | grep name
</code></pre>
<p>来查看材料库中有哪些材料。使用两次grep可以用来搜索相关材料，比如查看材料库中有哪些”Steel”可供选择:</p>
<pre><code class="bash">$ strings $HOME/.local/lib/python2.7/site-packages/pyne/nuc_data.h5 | grep name | grep &quot;Steel&quot;
</code></pre>
<h4 id="设置问题边界"><a href="#设置问题边界" class="headerlink" title="设置问题边界"></a>设置问题边界</h4><p>边界包括终止边界和反射边界等。终止边界指的是我们不关心的区域，中子进入到终止边界后就会被杀死，这和MCNP中<em>imp=0</em>的区域相似。反射边界就是反射面，中子到达反射面后会被反射回去，在对称几何中很常用。</p>
<h5 id="终止边界：graveyard"><a href="#终止边界：graveyard" class="headerlink" title="终止边界：graveyard"></a>终止边界：graveyard</h5><p>终止边界的设置实际上是通过对这个区域设置特殊材料实现的。比如此例题中需要将8号volume (可以简写为vol)设置为graveyard,可以使用下面命令进行设置：</p>
<pre><code>trelis&gt; group &quot;mat:Graveyard&quot; add volume 8
</code></pre><h5 id="反射边界"><a href="#反射边界" class="headerlink" title="反射边界"></a>反射边界</h5><p>反射边界是通过指定反射面的方式来设置的。与volume类似，我们可以把一些面加入到一个group，然后将这个group设置为反射面即可。反射面属性的设置也是通过把group名字设置为特殊字符串的方式实现。<br>比如将10, 11号曲面设置为反射面，可以通过下面的命令：</p>
<pre><code>trelis&gt; group &quot;boundary:Reflecting&quot; add surf 10 11
</code></pre><p>本例题中不需要将任何曲面设置为反射面。</p>
<h4 id="imprint-amp-merge"><a href="#imprint-amp-merge" class="headerlink" title="imprint &amp; merge"></a>imprint &amp; merge</h4><p>Imprint和merge是trelis中处理曲面的两个操作，他们的作用包括合并重合曲面和将无穷大的曲面根据几何体分割为总多的小的facet。功能说明可以参考<a href="https://svalinn.github.io/DAGMC/usersguide/trelis_basics.html" target="_blank" rel="noopener">trelis imprint and merge说明</a>。</p>
<p>我们需要做的是，在trelis界面执行下面的操作：</p>
<pre><code>trelis&gt; imprint body all
trelis&gt; merge all
</code></pre><h4 id="导出几何文件"><a href="#导出几何文件" class="headerlink" title="导出几何文件"></a>导出几何文件</h4><p>安装了DAGMC插件的trelis可以使用内置命令到处几何文件，使用方法可以通过下面命令查看帮助信息：</p>
<pre><code>trelis&gt; help dagmc
</code></pre><p>也可以参考<a href="https://svalinn.github.io/DAGMC/usersguide/codes/dag-mcnp.html" target="_blank" rel="noopener">官方文档</a>。</p>
<p>对于本例题，我们可以在trelis中执行下面命令将几何信息存放到”geometry1.h5m”中：</p>
<pre><code>trelis&gt; export dagmc geometry1.h5m
</code></pre><p>至此，我们完成了几何文件的制作。</p>
<p><strong>注意：在没有设置trelis默认导出文件路径的情况下，此时生成的”geometry1.h5m”文件并不一定在当前文件夹，可能存放于$HOME/Documents中，也可能在其他常用默认文件夹中</strong></p>
<h3 id="制作材料"><a href="#制作材料" class="headerlink" title="制作材料"></a>制作材料</h3><p>我们需要首先制作本例题需要使用的材料库，包括Water和Steel两种材料。可以参考<a href="https://zxkjack123.github.io/neutronics/make-pyne-material-lib/">PyNE材料库制作</a>。</p>
<p>备注：制作材料的时候会调用PyNE，需要保证此时系统<strong>LD_LIBRARY_PATH</strong>中的MOAB是4.9.1版本的。</p>
<h3 id="整合几何与材料"><a href="#整合几何与材料" class="headerlink" title="整合几何与材料"></a>整合几何与材料</h3><p>按照UWUW流程制作材料，使用UWUW_preprocessor：</p>
<pre><code class="bash">$ uwuw_preproc &lt;dagmc h5m filename&gt; -v -l &lt;path to nuclear data library&gt;
</code></pre>
<p>假设我们制作了材料库并存放在”material_lib1.h5”中，我们接下来就可以执行：</p>
<pre><code class="bash">$ uwuw_preproc geometry1.h5m -v -l material_lib1.h5
</code></pre>
<p>备注：整合几何和材料的时候需要调用DAGMC的功能，此时需要保证系统<strong>LD_LIBRARY_PATH</strong>中的MOAB版本是5.0版的。</p>
<h3 id="DAGMC-input文件准备"><a href="#DAGMC-input文件准备" class="headerlink" title="DAGMC input文件准备"></a>DAGMC input文件准备</h3><p>DAGMC的input文件中需要给定普通MCNP中除了栅元卡和曲面卡以及材料卡的其他部分，包括但不限于：</p>
<ol>
<li>中子源定义，必要项</li>
<li>计算终止条件，必要项</li>
<li>Tally卡，可选项，但一般都会有</li>
<li>其他功能性辅助卡，可选项，根据实际情况添加</li>
</ol>
<p>对于此例子的一个简单input文件如下：</p>
<pre><code>C test1 input
C neutron source: point source, 14 MeV
sdef pos=0 0 0  erg=14  
C 
nps 1e5
C Tally card
fmesh4:n geom=xyz origin= -5 -5 -5
         imesh=15 iints=2
         jmesh=5 jints=1
         kmesh=15 kints=2
         emesh 0.1 20
</code></pre><h2 id="中子输运计算"><a href="#中子输运计算" class="headerlink" title="中子输运计算"></a>中子输运计算</h2><p>使用DAGMC进行输运计算时，需要通过<strong>i=</strong>来指定输入文件，通过<strong>g=</strong>来指定加载了材料的几何文件，详细运行指令可以参考<a href="https://svalinn.github.io/DAGMC/usersguide/uw2.html" target="_blank" rel="noopener">官方文档</a>。</p>
<p>对于本例题，可以使用下面的方法运行本例子。<br>单线程运行：</p>
<pre><code># 需要先保障系统能够找到正确的mcnp5.mpi，找不到的话需要给出完整路径
mcnp5.mpi i=input g=geom.h5m
</code></pre><p>多线程运行：</p>
<pre><code>mpirun -np n mcnp5.mpi i=input g=geom.h5m
</code></pre><p>备注：input文件和几何文件的名称长度都不能超过8个字符，可以使用<strong>ln -sf original_long_name.h5m geom.h5m</strong>把原文件链接到一个较短名字的文件后再运行。</p>
<p>计算完成之后，我们便得到了一个<strong>meshtal</strong>文件。</p>
<h2 id="活化计算"><a href="#活化计算" class="headerlink" title="活化计算"></a>活化计算</h2><p>中子输运完成后，我们开始正式调用PyNE的<a href="http://pyne.io/usersguide/r2s.html?highlight=r2s" target="_blank" rel="noopener">R2S计算</a>模块的功能进行停机剂量率计算了。</p>
<p>进行停机剂量率计算，我们需要的主要信息包括：</p>
<ol>
<li>每个网格单元的材料成分。必须项。由同时包含了几何和材料的geom.h5m文件提供。（此文件就是进行DAGMC计算的那个）</li>
<li>每个网格单元的中子通量能谱。必须项。由meshtal文件提供。</li>
<li>活化计算能力。必须项。由Analytic and Laplacian Adaptive Radioactivity Analysis软件:<a href="https://github.com/svalinn/ALARA" target="_blank" rel="noopener">ALARA</a>提供。</li>
<li>辐照及冷却方案。必须项。需要在R2S过程中指定。</li>
</ol>
<p>在我们的工作文件夹下新建一个子文件夹用来存放R2S计算相关的文件。</p>
<pre><code class="bash">mkdir r2s_run
cd r2s_run
</code></pre>
<h3 id="初始化配置-setup"><a href="#初始化配置-setup" class="headerlink" title="初始化配置:setup"></a>初始化配置:setup</h3><p>初始化配置r2s。执行：</p>
<pre><code class="bash">r2s.py setup
</code></pre>
<p>备注：检查确认系统<strong>LD_LIBRARY_PATH</strong>中的MOAB为4.9.1版本，并且在安装PyNE时将相应路径加入到~/.bashrc文件中后，r2s.py将能够直接被系统找到(which r2s.py)。</p>
<p>执行之后我们应该能够看到下面的信息：</p>
<pre><code># 一些warning
File &quot;config.ini&quot; has been written
File &quot;alara_params.txt&quot; has been written
Fill out the fields in these filse then run &quot;&gt;&gt; r2s.py step1&quot;
</code></pre><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p><strong>setup</strong>这一步会生成两个文件：<strong>config.ini</strong>和<strong>alara_params.txt</strong>，我们需要修改这两个文件中的一些设置，包括辐照方案的设置和一些计算细节的设置。</p>
<h4 id="修改config-ini设置"><a href="#修改config-ini设置" class="headerlink" title="修改config.ini设置"></a>修改<strong>config.ini</strong>设置</h4><p>一般情况下，我们需要注意的几个设置是：</p>
<ol>
<li>structured: 是否是结构化网格。结构化网格就是指MCNP中用的xyz或cyl网格。我们应该选<strong>True</strong></li>
<li>sub_voxel: 是否采用sub_voxel模式，sub_voxel模式是我正在添加的代码，还没有完成，暂时不能选用，因此是False</li>
<li>reverse: 反转中子通量顺序。DAGMC输出的中子通量是按照从低能到高能排序，而用ALARA进行活化计算时需要按照从高能到低能读取，因此需要把中子通量逆序排列。这里填True。</li>
</ol>
<pre><code class="python">[general]
# Specify whether this problem uses structured or unstructured mesh
structured: True
# Specify whether this problem uses sub-voxel r2s
sub_voxel: False

[step1]
# Path to MCNP MESHTAL file containing neutron fluxes or a DAG-MCNP5
# unstructured mesh tally .h5m file.
meshtal: meshtal
# Tally number within the meshtal file containing the fluxes for activation.
tally_num: 4
# The name of the tag used to store flux data on the mesh. For unstructured
# mesh this tag must already exist within the file specified in &lt;meshtal&gt;.
flux_tag: n_flux
# Path to the DAGMC material-laden geometry file (.h5m).
geom: geom.h5m
# If True the fluxes in the fluxin file will be printed in the reverse
# order of how they appear within the flux vector tag. Since MCNP and
# the Meshtal class order fluxes from low energy to high energy, this
# option should be true if the transmutation data being used is
# ordered from high-energy to low-energy.
reverse: True
# Number of rays to fire down each mesh row in each direction to calculate
# cell volume fractions.
num_rays: 10
# If true, rays will be fired down mesh rows in evenly spaced intervals.
# In this case &lt;num_rays&gt; must be a perfect square. If false, rays are fired
# down mesh rows in random intervals.
grid: False

[step2]
# List of decays times, seperated by commas. These strings much match exactly
# with their counterparts in the phtn_src file produced in step1. No spaces
# should appear in this line except the space between the time and the time unit
# for each entry.
decay_times:1 h
# The prefix of the .h5m files containing the source density distributations for
# each decay time.
output: source
# The name of the output files containing the total photon source intensities for
# each decay time
tot_phtn_src_intensities : total_photon_source_intensites.txt
</code></pre>
<h4 id="修改alara-params-txt"><a href="#修改alara-params-txt" class="headerlink" title="修改alara_params.txt"></a>修改alara_params.txt</h4><pre><code>material_lib alara_matlib
element_lib data/nuclib
data_library alaralib data/truncated_fendl2bin

cooling
    1 h
end

output zone
       integrate_energy
       # Energy group upper bounds. The lower bound is always zero.
       photon_source  data/truncated_fendl2bin  phtn_src 24 1.00E4 2.00E4 5.00E4 1.00E5
       2.00E5 3.00E5 4.00E5 6.00E5 8.00E5 1.00E6 1.22E6 1.44E6 1.66E6
       2.00E6 2.50E6 3.00E6 4.00E6 5.00E6 6.50E6 8.00E6 1.00E7 1.20E7
       1.40E7 2.00E7
end

#     flux name    fluxin file   norm   shift   unused
flux  my_flux     alara_fluxin  1e10     0      default

# Specify the irradiation schedule below.
# Syntax is found in the ALARA user manual
# This example is for a single 1 y pulse
schedule    my_schedule
    1 y my_flux my_pulse_history 0  s
end
pulsehistory  my_pulse_history
    1    0.0    s
end

#other parameters
truncation 1e-12
impurity 5e-6 1e-3
dump_file dump.file
</code></pre><h3 id="r2s-py-step1"><a href="#r2s-py-step1" class="headerlink" title="r2s.py step1"></a>r2s.py step1</h3><p><strong>r2s.py step1</strong>是用来根据<strong>r2s.py setup</strong>生成的配置文件生成ALARA输入文件，中子通量文件和ALARA材料库文件的。</p>
<p>当我们修改好上面两个文件后，就可以使用r2s.py生成ALARA计算需要的文件了：</p>
<pre><code class="bash">$ r2s.py step1
</code></pre>
<h3 id="材料数据库准备"><a href="#材料数据库准备" class="headerlink" title="材料数据库准备"></a>材料数据库准备</h3><p><strong>ALARA输入文件</strong>中有三行是<strong>材料数据库</strong>相关的信息。</p>
<ol>
<li>material_lib alara_matlib 这个<strong>alara_matlib</strong>是alara需要读取的材料成功定义的文件名。这个文件是会由程序从test1_geometry.h5m (geom.h5m)中读取的，不需要做修改。</li>
<li>element_lib data/nuclib 这个文件是定义元素的丰度用的。默认是自然丰度，也可以自己定义修改丰度。自己定义一个元素丰度数据表显然是非常麻烦的，在ALARA的安装文件中$ALARA/data下有一个<strong>elelib.std</strong>，可以把这个文件拷贝到工作文件夹下并重命名为<strong>nucib</strong>即可（也可以设置element_lib elelib.std)。但是这个<strong>elelib.std</strong>只能用于材料定义是按照元素定义的，如果有针对核素的定义，则这个就不能用了。需要将元素扩展成核素，需要后续介的方法单独处理。</li>
<li>data_library alaralib truncated_fendl2bin （ALARA应该配备fendl3bin)但是并没有，ALARA安装文件中的sample/datam文件夹下只有truncated_fendl2bin数据库。我们可以把这个数据库相关的文件拷贝到工作文件夹。</li>
</ol>
<p>当材料定义是针对核素定义了的化，普通的<strong>elelib.std</strong>就没办法使用了，会出现错误：</p>
<pre><code>310: Could not find element &lt;string&gt; in element library.

The element string was not found in the element library. This could be due to an error in the material library, incorrect user input, or an omission in the element library.
</code></pre><p>这时我们需要使用工具<strong>elelib_to_nuclib.py</strong>来将元素扩展成核素数据。这个工具是一个python脚本，调用pyne数据模块扩展元素数据。工具的位置在ALARA源文件的tools文件夹下，使用方法：</p>
<pre><code class="bash">$ cd r2s_run/data
$ python &lt;path_to_elelib_to_nuclib.py&gt; elelib_std -o nuclib
</code></pre>
<h3 id="alara计算"><a href="#alara计算" class="headerlink" title="alara计算"></a>alara计算</h3><p>当<strong>step1</strong>完成后，程序会给出运行alara的提示，按照提示运行：</p>
<pre><code class="bash">$ alara alara_geom &gt; output.txt
</code></pre>
<p>等待alara运行完成，会生成几个文件：</p>
<ol>
<li>output.txt: ALARA输出文件，里面有活化后材料的核素组成以及光子发射率数据</li>
<li>phtn_src: ALARA输出文件，里面有详细的各个各个材料各个核素缠身的各个能群的光子数据</li>
</ol>
<h3 id="r2s-step2"><a href="#r2s-step2" class="headerlink" title="r2s step2"></a>r2s step2</h3><p>ALARA计算完成后，运行：</p>
<pre><code class="bash">$ r2s.py step2
</code></pre>
<p>执行完成后，我们可以看到工作文件夹中多了几个文件：</p>
<ol>
<li>e_bounds:光子能群结构。从低能到高能，单位为eV。最低能群能量下限为0.</li>
<li>phtn_src.h5: HDF5格式的光子源数据，无法直接打开读取，只能程序读。</li>
<li>source_<strong>i</strong>.h5m: 第<strong>i</strong>个冷却时间点的网格光子源数据。</li>
<li>total_photon_source_intensites.txt: 里面是各个冷却时间节点的总光子发射率。<br>你</li>
</ol>
<h2 id="光子输运"><a href="#光子输运" class="headerlink" title="光子输运"></a>光子输运</h2><p>获得光子源后，我们就可以进行光子输运计算了。计算前必须确认DAGMC是已经包含了源子程序的版本，如果没有，需要先参考<a href="编译带用于R2S的源子程序的DAGMC">编译带用于R2S的源子程序的DAGMC</a>安装DAGMC。</p>
<h3 id="文件准备"><a href="#文件准备" class="headerlink" title="文件准备"></a>文件准备</h3><p>进行光子输运计算，我们需要提供几何文件，材料，光子源，以及需要统计的信息。因此需要准备的文件有：</p>
<ol>
<li>geom.h5m: 就是中子输运时用的那个文件，即本例子中的test1_geometry.h5m，它包含了几何和材料信息</li>
<li>source.h5m:光子源信息文件，源子程序需要从这里读取信息。由于MCNP无法从输入文件中传递字符串，所以这个文件名称不能改变，必须是source.h5m。</li>
<li>e_bounds: 光子能群结构文件。</li>
<li>input: 提供tally信息，另外需要在这个文件中定义<strong>idum</strong>，用于控制源子程序过程。</li>
</ol>
<p>准备好这些文件后，我们还需要对这些文件进行一些小修改。</p>
<ol>
<li>input文件修改：首先，需要加上mode p， 然后修改tally部分。</li>
<li>e_bounds: 这个文件中的能群单位是eV而不是MeV，需要手动将里面的数据单位除以1e6。（在github上提交该修改建议）</li>
</ol>
<p>我们还需要修改栅元的重要性，因为中子输运时的文件里面的重要性是默认为中子的重要性，没有光子的重要性。但是这个重要性信息是写在h5m文件里面的，没法直接修改。</p>
<p>我们需要先运行一次这个文件：</p>
<pre><code class="bash">$ mcnp5.mpi i=input g=geom.h5m
</code></pre>
<p>现在这个运行肯定会出现错误，说粒子产生子重要性为0的区域。但是同时这个过程会生成一个可编辑的<strong>lcad</strong>文件，我们可以修改这个<strong>lcad</strong>文件，在重要性部分添加上<strong>imp:p=1</strong>/<strong>imp:p=0</strong>，将这个文件重命名为<strong>lcad_m</strong>，删掉过程文件<strong>fcad, outp, runtpe</strong>后再次运行</p>
<pre><code class="bash">$ mcnp5.mpi i=input g=geom.h5m l=lcad_m
</code></pre>
<p>之后就得到结果，至此停机剂量的计算完成。</p>
<p><strong>备注</strong>：在计算得到结果之后，还可以把几何图形及计算结果的网格数据进行可视化绘图。绘图方法可以参考<a href="https://zxkjack123.github.io/neutronics/dagmc-geom-data-visualization/">DAGMC数据绘图</a>。</p>
]]></content>
      
        <categories>
            
            <category> neutronics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Trelis </tag>
            
            <tag> DAGMC </tag>
            
            <tag> PyNE </tag>
            
            <tag> R2S </tag>
            
            <tag> shutdown dose rate </tag>
            
            <tag> 停机计量 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DAGMC几何和数据可视化]]></title>
      <url>/neutronics/dagmc-geom-data-visualization/</url>
      <content type="html"><![CDATA[<p>科学计算达到了结果之后，总是希望能够画出酷炫的图来展示自己的成果。比如说展示复杂几何结构的的图，展示数据在空间分布的图，或者两者结合起来的几何和数据匹配的图。</p>
<p>我们在使用DAGMC的过程中，除了Trelis几何模型处理阶段有图形以外，我们还可以把meshtal的结果和几何一起展示出来。</p>
<p>要制作这种几何和数据结合的图，我们可以使用<a href="https://wci.llnl.gov/simulation/computer-codes/visit" target="_blank" rel="noopener">visit</a>这款软件。</p>
<p>我们把几何文件和数据文件都转换为vtk格式，然后用visit就可以画图了。</p>
<h2 id="几何模型准备"><a href="#几何模型准备" class="headerlink" title="几何模型准备"></a>几何模型准备</h2><p>经过Trelis处理到处的geom.h5m文件可以使用MOAB的工具mbconvert将h5m文件转化为vtk文件。</p>
<p>不过我们不能直接使用那个用于输运计算的几何文件。因为那个文件中存在一个graveyard，那个是我们添加在原本几何模型外围的中子计算截止区域的几何。我们不需要这个graveyard，需要在Trelis模型中去掉这部分，导出一个没有graveyard的几何文件。</p>
<h2 id="数据文件准备"><a href="#数据文件准备" class="headerlink" title="数据文件准备"></a>数据文件准备</h2><p>我们得到meshtal文件后，可以通过PyNE这个工具来将其先转化为h5m文件，然后再通过mbconvert转化为vtk文件。</p>
<h3 id="meshtal数据写入h5m文件"><a href="#meshtal数据写入h5m文件" class="headerlink" title="meshtal数据写入h5m文件"></a>meshtal数据写入h5m文件</h3><p>比如一个包含fmesh4和fmesh14的meshtal文件，可以通过下面的python脚本将这两个tally的数据写入到h5m文件中：</p>
<pre><code class="python">from pyne.mcnp import Meshtal
from pyne.mesh import IMeshTag
#neutron_result neutron_result_rel_error neutron_result_total neutron_result_total_rel_error
meshtal = Meshtal(&quot;meshtal&quot;)
meshtal.tally[4].mesh.save(&quot;meshtal4.h5m&quot;)
meshtal.tally[14].mesh.save(&quot;meshtal14.h5m&quot;)
</code></pre>
<h3 id="将h5m文件转化为vtk文件"><a href="#将h5m文件转化为vtk文件" class="headerlink" title="将h5m文件转化为vtk文件"></a>将h5m文件转化为vtk文件</h3><p>使用下面的命令将h5m文件转化为vtk文件：</p>
<pre><code class="bash">$ mbconvert meshtal4.h5m meshtal4.vtk
$ mbconvert meshtal14.h5m meshtal14.vtk
</code></pre>
<h2 id="visit绘图"><a href="#visit绘图" class="headerlink" title="visit绘图"></a>visit绘图</h2><h3 id="单独绘制几何"><a href="#单独绘制几何" class="headerlink" title="单独绘制几何"></a>单独绘制几何</h3><p>运行visit -&gt; File -&gt; Open file -&gt; 选择几何vtk文件 -&gt; 在窗口找到Plots子窗口 -&gt; 点击Add下单菜单 -&gt; 选择mesh -&gt; 选择mesh -&gt; 窗口出现一个对象 -&gt; 点击Plots子窗口Draw按钮 </p>
<p>按照上述流程几何显示出几何文件的网格结构图。</p>
<p>下图是<a href="https://zxkjack123.github.io/neutronics/sample-trelis-dagmc-pyne-r2s-workflow/">计算停机剂量的例子</a>中的几何图形：<br><img src="https://i.imgur.com/pudCxoD.png" alt="几何图"></p>
<h3 id="单独绘制数据"><a href="#单独绘制数据" class="headerlink" title="单独绘制数据"></a>单独绘制数据</h3><p>与绘制几何类似：</p>
<p>运行visit -&gt; File -&gt; Open file -&gt; 选择数据vtk文件 -&gt; 在窗口找到Plots子窗口 -&gt; 点击Add下单菜单 -&gt; 选择pseudocolor -&gt; 选择相应的tally tag -&gt; 窗口出现一个对象 -&gt; 点击Plots子窗口Draw按钮 </p>
<p><img src="https://i.imgur.com/Wg8jHmn.png" alt="剂量图"></p>
<h3 id="同时绘制几何和数据"><a href="#同时绘制几何和数据" class="headerlink" title="同时绘制几何和数据"></a>同时绘制几何和数据</h3><p>同时绘制几何和数据的操作其实就是将几何和图像同时话在同一个图上，操作流程就是上述两者的结合。</p>
<p><img src="https://i.imgur.com/28Ko0SN.png" alt="几何加图"></p>
]]></content>
      
        <categories>
            
            <category> neutronics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Trelis </tag>
            
            <tag> DAGMC </tag>
            
            <tag> PyNE </tag>
            
            <tag> visit </tag>
            
            <tag> visualization </tag>
            
            <tag> geometry </tag>
            
            <tag> data </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安装DAGMC]]></title>
      <url>/neutronics/dagmc-install/</url>
      <content type="html"><![CDATA[<h2 id="DAGMC简介"><a href="#DAGMC简介" class="headerlink" title="DAGMC简介"></a>DAGMC简介</h2><p><a href="https://svalinn.github.io/DAGMC/" target="_blank" rel="noopener">DAGMC</a>是Direct Accelerated Geometry Monte Carlo的缩写，如其名字所示，DAGMC设计了一套方便高效的几何手段，用于蒙特卡罗方法的计算。DAGMC已经有了与MCNP5, MCNP6, Geant4, FLUKA, Tripoli4和Shift结合的相应工具。即使用DAGMC的几何处理部分，配合其他工具的物理计算部分代码，实现蒙特卡罗计算。</p>
<h2 id="DAGMC依赖软件安装"><a href="#DAGMC依赖软件安装" class="headerlink" title="DAGMC依赖软件安装"></a>DAGMC依赖软件安装</h2><p>DAGMC可以用来和PyNE配合来进行停机剂量计算工作。但是，现在PyNE最高支持MOAB 4.9.1 版，然而DAGMC需要使用MOAB 5.0版。也就是说，使用DAGMC的PyNE开发者需要在电脑上同时安装MOAB 4.9.1 和5.0版本。必须分别安装并设定，使用时还需要指定所使用库的路径。PyNE的安装可以参考<a href="https://zxkjack123.github.io/neutronics/pyne-developer-install/">PyNE的开发版本安装</a>。DAGMC的安装可以参考<a href="https://svalinn.github.io/DAGMC/install/index.html" target="_blank" rel="noopener">官方安装指导</a>。但是官方指导的安装步骤存在几个缺点：</p>
<ol>
<li>对于HDF5的安装和库的使用有一处会出现找不到hdf5的情况</li>
<li>虽然说明了需要安装MOAB5.0,但并没有明确的和MOAB4.9.1做区分，导致使用PyNE的人会面临困扰</li>
<li>部分系统上，如Ubuntu 16.04，安装MOAB时会出现bug，暂时需要手动解决</li>
</ol>
<p>我也正在梳理适合我实际的安装流程，同时争取把官方安装指导完善一下。不过由于PyNE和DAGMC都还在不断的开发和完善过程中，将来对于MOAB的配置问题如果得到解决，那么整个安装流程就又会发生改变。安装流程需要与时俱进。</p>
<h3 id="安装HDF5"><a href="#安装HDF5" class="headerlink" title="安装HDF5"></a>安装HDF5</h3><p>电脑中可能已经安装了HDF5了，我们可以通过下面的命令来检查它的版本：</p>
<pre><code class="bash">dpkg -s libhdf5-dev
</code></pre>
<p>如果没有安装的话，通过下面的命令安装：</p>
<pre><code class="bash">sudo apt-get install hdf5-dev
</code></pre>
<h3 id="安装MOAB5-0"><a href="#安装MOAB5-0" class="headerlink" title="安装MOAB5.0"></a>安装MOAB5.0</h3><p>假定我们将MOAB5.0安装在$HOME/opt/MOAB5.0下，按照以下步骤进行安装。</p>
<h4 id="获取源代码"><a href="#获取源代码" class="headerlink" title="获取源代码"></a>获取源代码</h4><pre><code class="bash"># 下载源代码
cd ~/opt
mkdir MOAB5.0
cd MOAB5.0
git clone https://bitbucket.org/fathomteam/moab
cd moab
git checkout Version5.0
autoreconf -fi
cd ..
ln -s moab src
</code></pre>
<h4 id="配置安装"><a href="#配置安装" class="headerlink" title="配置安装"></a>配置安装</h4><pre><code>mkdir bld
cd bld
export MOAB_DIR=$HOME/opt/MOAB5.0
../src/configure --enable-optimize \
                   --enable-shared \
                   --disable-debug \
                   --with-hdf5=/usr/lib/x86_64-linux-gnu/hdf5/serial \
                   --prefix=$MOAB_DIR
make
</code></pre><p>目前由于MOAB的配置文件存在bug,执行到这一步时，会出现下面的报错：</p>
<pre><code>../../src/src/moab/Matrix3.hpp:62:2: error: #error Need either Eigen3 or BLAS/LAPACK libraries
</code></pre><p>解决方法：</p>
<pre><code class="bash">cd $MOAB_DIR/src/src/moab
</code></pre>
<p>打开<strong>Matrix3.hpp</strong>,找到下面的一段内容：</p>
<pre><code class="hpp">// We will rely on LAPACK directly
#ifndef MOAB_HAVE_LAPACK
#error Need either Eigen3 or BLAS/LAPACK libraries
#endif
</code></pre>
<p>将<strong>#error Need either Eigen3 or BLAS/LAPACK libraries</strong>注释掉：</p>
<pre><code class="hpp">// We will rely on LAPACK directly
#ifndef MOAB_HAVE_LAPACK
//#error Need either Eigen3 or BLAS/LAPACK libraries
#endif
</code></pre>
<p>然后清空bld文件家下的所有内容，重新配置安装：</p>
<pre><code class="bash">cd $MOAB_DIR/bld
rm -rf ./*
../src/configure --enable-optimize \
                   --enable-shared \
                   --disable-debug \
                   --with-hdf5=/usr/lib/x86_64-linux-gnu/hdf5/serial \
                   --prefix=$MOAB_DIR
make
make check
make install
</code></pre>
<p>至此，我们完成了MOAB5.0的安装，但是要调用它，必须让系统能够找到相关的文件。由于系统中可能同时安装了MOAB4.9.1和MOAB5.0，因此我们需要设置好MOAB的路径。</p>
<h4 id="路径设置"><a href="#路径设置" class="headerlink" title="路径设置"></a>路径设置</h4><p>MOAB路径配置,将下面的内容拷贝至~/.bashrc文件：</p>
<pre><code># MOAB
export MOAB_DIR=$HOME/opt/MOAB5.0
#export MOAB_DIR=$HOME/opt/MOAB4.9.1
export PATH=$PATH:$MOAB_DIR/bin
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$MOAB_DIR/lib
export LIBRARY_PATH=$LIBRARY_PATH:$MOAB_DIR/lib
export CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:$MOAB_DIR/include
export C_INCLUDE_PATH=$C_INCLUDE_PATH:$MOAB_DIR/include
</code></pre><p>这样，当需要使用DAGMC的时候，将~/.bashrc中的MOAB4.9.1路径注释掉，保留MOAB5.0，然后打开一个新的terminal（刷新~/.bashrc设置），新terminal中MOAB便是MOAB5.0。</p>
<pre><code>export MOAB_DIR=$HOME/opt/MOAB5.0
#export MOAB_DIR=$HOME/opt/MOAB4.9.1
</code></pre><p>当需要使用PyNE的时候，将~/.bashrc中的MOAB5.0注释掉，保留MOAB4.9.1，然后打开一个新的terminal，新的terminal中MOAB便是MOAB4.9.1。</p>
<pre><code>#export MOAB_DIR=$HOME/opt/MOAB5.0
export MOAB_DIR=$HOME/opt/MOAB4.9.1
</code></pre><h2 id="安装DAGMC"><a href="#安装DAGMC" class="headerlink" title="安装DAGMC"></a>安装DAGMC</h2><p>完成HDF5和MOAB5.0的安装后，我们可以安装DAGMC了。</p>
<p>假设我们要把DAGMC安装在$HOME/opt/DAGMC文件夹下，可以按照下面的步骤进行。</p>
<h3 id="获取DAGMC源代码"><a href="#获取DAGMC源代码" class="headerlink" title="获取DAGMC源代码"></a>获取DAGMC源代码</h3><pre><code class="bash">cd $HOME/opt
mkdir DAGMC
cd DAGMC
git clone https://github.com/svalinn/DAGMC
# 此处会在DAGMC文件夹下再生成一个DAGMC文件夹-&gt; DAGMC/DAGMC
cd DAGMC
git checkout develop
</code></pre>
<h3 id="安装DAGMC-1"><a href="#安装DAGMC-1" class="headerlink" title="安装DAGMC"></a>安装DAGMC</h3><p><strong>这个步骤需要相应的物理计算部分的源代码</strong>。请参考<a href="https://svalinn.github.io/DAGMC/install/dagmc.html" target="_blank" rel="noopener">官方文档</a>选择相应版本执行后续安装步骤。<br>下面以安装DAG-MCNP v1.xx为例说明安装过程</p>
<h4 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h4><pre><code class="bash">cd mcnp/mcnp5
cp -r &lt;path_to_dvd&gt;/MCNP5/Source .
chmod -R u+rw Source
patch -p0 &lt; patch/dagmc.5.1.xx.patch
</code></pre>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><pre><code class="bash">cd $HOME/opt/DAGMC/DAGMC
mkdir bld
cd bld
cmake ../. -DBUILD_MCNP5=ON -DMPI_BUILD=ON -DCMAKE_INSTALL_PREFIX=$HOME/opt/DAGMC -DHDF5_LIBRARIES=/usr/lib/x86_64-linux-gnu/hdf5/serial/lib -DHDF5_INCLUDE_DIRS=/usr/lib/x86_64-linux-gnu/hdf5/serial/include -DMCNP5_DATAPATH=$HOME/opt/MCNPDATA
make
make install
</code></pre>
<h4 id="添加路径到-bashrc"><a href="#添加路径到-bashrc" class="headerlink" title="添加路径到~/.bashrc"></a>添加路径到~/.bashrc</h4><pre><code>export PATH=$PATH:$HOME/opt/DAGMC/bin
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$HOME/DAGMC/lib
</code></pre><h2 id="编译带用于R2S的源子程序的DAGMC"><a href="#编译带用于R2S的源子程序的DAGMC" class="headerlink" title="编译带用于R2S的源子程序的DAGMC"></a>编译带用于R2S的源子程序的DAGMC</h2><p>上面的步骤是编译DAGMC的通用流程。但是当我们需要配合PyNE进行R2S计算的DAGMC时，需要修改源子程序，修改及其编译说明可以参考<a href="http://pyne.io/usersguide/source_sampling.html#source-sampling-in-mcnp5" target="_blank" rel="noopener">官方文档</a>。</p>
<p>如果是第一次安装DAGMC，想直接安装配合PyNE的DAGMC，那么需要上述安装步骤的<strong>patch之后配置之前</strong>加入如下步骤：</p>
<ol>
<li>Navigate to the folder MCNP5/Source/src.</li>
<li>Soft-link the following files into this folder:<ul>
<li>pyne/src/source_sampling.cpp</li>
<li>pyne/src/source_sampling.h</li>
<li>pyne/src/measure.cpp</li>
<li>pyne/src/measure.h</li>
</ul>
</li>
<li>Remove the pre-existing empty source.F90 file.</li>
<li>Soft-link pyne/share/source.F90.</li>
<li>Open the file MCNP/Source/src/FILE.list.</li>
<li>Edit file, add CXX_SRC under C_SRC to include the additional source files. It should look like “CXX_SRC := measure.cpp source_sampling.cpp”.</li>
</ol>
<p>然后接着配置之后的步骤进行即可。</p>
<p>如果是已经安装过DAGMC，则可以省去patch及patch之前的步骤，直接使用上面的修改，然后进行配置编译即可。</p>
<p><strong>备注</strong>： 进行上述修改步骤时，必须注意两点：</p>
<ol>
<li>确保系统路径中的MOAB是5.0版本</li>
<li>确保pyne的branch是你需要的branch</li>
</ol>
]]></content>
      
        <categories>
            
            <category> neutronics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DAGMC </tag>
            
            <tag> install </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Volunteering as Chinese tutor]]></title>
      <url>/English/Volunteering-as-Chinese-tutor/</url>
      <content type="html"><![CDATA[<p>There is a student organized group providing a Greater University Tutoring Service (GUTS) at University of Wisconsin. GUTS is a service for students who are learning languages other than English. Students learning foreign languages can apply to be a tutor to teach others his or her native language, or apply to be a tutee to learn a new language form a tutor. </p>
<p>For example, I am a native Chinese speaker, and I am now learning both English and Japanese. I applied to be a tutor to teach another student Chinese. And I also applied to learn Japanese from others. However, I can’t apply for learning English in this program. </p>
<p>This is a student community similar to Lang-8 in that language learners benefit each other. But the GUTS focus more on oral communications, i.e. listening and speaking, while Lang-8 focus more on written communication. </p>
<p>Now, they’ve matched me a tutee named Molly who is learning Chinese, but we haven’t met yet. I hope we enjoy the teaching and learning experience this semester. </p>
<p>However, there are only about 15 Japanese students on campus, and only a few people do volunteer work at GUTS. Unfortunately, I won’t get a tutor because they all already have tutees. </p>
<p>However, I was told that there is a Japanese student association and they will be having a spring kickoff event this Saturday and that students from other countries are also welcome to attend. I am planning to attend and meet some Japanese friends. It would be great if I had more chances to use Japanese to express myself, but I don’t know whether they have free time to tutor me. </p>
<p>Even worse, I don’t know whether or not they are willing to make a Chinese friend like me. Nevertheless, but I think I should at least try. So, I need to practice greeting phrases several times before the spring kickoff.</p>
]]></content>
      
        <categories>
            
            <category> English </category>
            
        </categories>
        
        
        <tags>
            
            <tag> English </tag>
            
            <tag> volunteering </tag>
            
            <tag> tutor </tag>
            
            <tag> Chinese </tag>
            
            <tag> Japanese </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Expressing Myself]]></title>
      <url>/English/expressing-myself/</url>
      <content type="html"><![CDATA[<p>I have been learning English in China since 2005. However, I still don’t have confidence in my English.</p>
<p>I’m now studying at the University of Wisconsin Madison. I am immersed in an English environment now. It is at this place that I have chances to speak directly to native English speakers. I need to use English to listen to others, to talk with others, to read articles and to write messages. </p>
<p>As for the listening and reading, I can generally understand others, except some jokes based on local things.</p>
<p>However, it’s a little hard for me to deliver my message to others. Some sentences confuse my friends. Sometimes it is a grammar problem, I made lots of mistakes on tenses and single/plural. Sometimes it is a vocabulary problem, I misspelled the important words. Well, these are still not the most serious difficulty. It is the phrase, especially the prepositional phrase that causes most misunderstanding. </p>
<p>Most Chinese have the same difficulties as me. I know the reason behind this phenomenon. The education and test method drive students to focus on reading and listening, to receive messages and to understand others. However, they have limited chance to practice expressing themselves. </p>
<p>I have to practice expressing myself more and more. I am also writing blog posts about my daily life and work. I think I can post the content on <a href="http://lang-8.com/551925/journals/166174560066022122116559685041472801357" target="_blank" rel="noopener">lang-8</a> first, and then post it to my blog after reviewing.</p>
]]></content>
      
        <categories>
            
            <category> English </category>
            
        </categories>
        
        
        <tags>
            
            <tag> English </tag>
            
            <tag> blog </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安装ALARA]]></title>
      <url>/neutronics/alara-install/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>中子活化计算是和中子学分析的重要一环。国际上用的比较多有<a href="http://www.ccfe.ac.uk/fispact.aspx" target="_blank" rel="noopener">FISPACT</a>, <a href="http://www.oecd-nea.org/tools/abstract/detail/nea-1839" target="_blank" rel="noopener">ACAB</a>和<a href="http://www.oecd-nea.org/tools/abstract/detail/nea-1839" target="_blank" rel="noopener">ALARA</a>。</p>
<p>文献上能看到很多用MCNP + FISPACT或者MCNP + ACAB的组合进行核分析的案例。不过FISPACT是收费软件，ACAB好像更难获取（连官方说明手册都没法下载全文）。</p>
<p>ALARA也是一款能够计算活化的软件。经常和PyNE, DAGMC配合的软件就是这款ALARA。</p>
<p>ALARA是开源软件，可以在其<a href="https://github.com/svalinn/ALARA" target="_blank" rel="noopener">Github主页</a>获取,在这里参考<a href="http://alara.engr.wisc.edu/users.guide.html/" target="_blank" rel="noopener">使用说明</a>。</p>
<h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>假设我们想把ALARA安装在<code>$HOME/opt/ALARA/</code>文件夹下，我们可以参照下面步骤进行。</p>
<h3 id="配置安装"><a href="#配置安装" class="headerlink" title="配置安装"></a>配置安装</h3><pre><code class="bash">$ cd opt
$ mkdir ALARA
$ cd ALARA
$ git clone https://github.com/svalinn/ALARA
# 此时在$HOME/opt/ALARA/下又生成了一个ALARA文件夹
$ cd ALARA
# ALARA主页上的使用说明少了这个autoreconf命令
$ autoreconf -fi
# 建立bld文件夹用来存放build过程文件
$ cd ..
$ mkdir bld
$ cd bld
$ ../ALARA/configure --prefix=$HOME/opt/ALARA
$ make
$ make install
</code></pre>
<h3 id="路径配置"><a href="#路径配置" class="headerlink" title="路径配置"></a>路径配置</h3><p>回到<code>$HOME/opt/ALARA</code>文件夹下，我们可以看到生成了<code>bin</code>,<code>data</code>,<code>doc</code>和<code>sample</code>文件夹。我们已经安装成功。不过要想轻松的使用它，必须要把它的可执行文件路径加到<code>~/.bashrc</code>中：</p>
<pre><code class="bash">export PATH=$PATH:$HOME/opt/ALARA/bin
</code></pre>
<p>保存<code>~/.bashrc</code>并在terminal上运行</p>
<pre><code class="bash">$ source ~/.bashrc
</code></pre>
<p>然后系统就可以找到alara了。</p>
<pre><code class="bash">$ which alara
</code></pre>
<h2 id="小测试"><a href="#小测试" class="headerlink" title="小测试"></a>小测试</h2><p>未完待续</p>
]]></content>
      
        <categories>
            
            <category> neutronics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> neutronics </tag>
            
            <tag> ALARA </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Cython返回Python类对象]]></title>
      <url>/cython/cython-return-object/</url>
      <content type="html"><![CDATA[<p>在之前的一篇博客<a href="https://zxkjack123.github.io/cython/cython-hello-world/">Cython调用C++函数例子</a>中，我参照Cython文档练习了用Python通过Cython调用C++库中的函数的例子。不过这个例子中，只有一个C++类，而且所有返回对象都是系统预定义的<strong>int</strong>,<strong>void</strong>之类的。</p>
<p>然而我的目标是<strong>返回一个可以调用C++类函数的Python类对象。而且是在类A中生成一个类B的对象返回。</strong></p>
<p>摸索一番后，我终于学会了实现这个功能的方法。<br>下面是把<a href="http://cython.readthedocs.io/en/latest/src/userguide/wrapping_CPlusPlus.html#create-cython-wrapper-class" target="_blank" rel="noopener">官方文档</a>的例子简单扩展一下用来联系的例题。</p>
<h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h2><h3 id="h文件"><a href="#h文件" class="headerlink" title="h文件"></a>h文件</h3><p>在官方文档的基础上，添加了一个Triangle类。另外把所有的int类型变量换成了double类型。<br>Rectangle.h:</p>
<pre><code class="C++">namespace shapes {
    class Triangle {
    public:
        double x0, y0, x1, y1, x2, y2;
        Triangle();
        Triangle(double x0, double y0, double x1, double y1, double x2, double y2);
        ~Triangle();
        double getArea();
    };

    class Rectangle {
    public:
        double x0, y0, x1, y1;
        Rectangle();
        Rectangle(double x0, double y0, double x1, double y1);
        ~Rectangle();
        double getArea();
        void getSize(double* width, double* height);
        void move(double dx, double dy);
    };


}
</code></pre>
<h3 id="cpp文件"><a href="#cpp文件" class="headerlink" title="cpp文件"></a>cpp文件</h3><p>Rectangle.cpp:</p>
<pre><code class="C++">#include &lt;math.h&gt;
#include &quot;Rectangle.h&quot;

namespace shapes {

  Rectangle::Rectangle() { }

    Rectangle::Rectangle(double X0, double Y0, double X1, double Y1) {
        x0 = X0;
        y0 = Y0;
        x1 = X1;
        y1 = Y1;
    }

    Rectangle::~Rectangle() { }

    double Rectangle::getArea() {
        return (x1 - x0) * (y1 - y0);
    }

    void Rectangle::getSize(double *width, double *height) {
        (*width) = x1 - x0;
        (*height) = y1 - y0;
    }

    void Rectangle::move(double dx, double dy) {
        x0 += dx;
        y0 += dy;
        x1 += dx;
        y1 += dy;
    }

    Triangle::Triangle(){

    }

    Triangle::Triangle(double x0, double y0, double x1, double y1, double x2, double y2) {
        this-&gt;x0 = x0;
        this-&gt;y0 = y0;
        this-&gt;x1 = x1;
        this-&gt;y1 = y1;
        this-&gt;x2 = x2;
        this-&gt;y2 = y2;
    }

    Triangle::~Triangle() {}

    double Triangle::getArea() {
        return fabs(0.5*((x1-x0)*(y2-y0) - (x2-x0)*(y1-y0)));
    }
}
</code></pre>
<h2 id="pyx文件"><a href="#pyx文件" class="headerlink" title="pyx文件"></a>pyx文件</h2><p>rect.pyx:</p>
<pre><code class="python">cdef extern from &quot;Rectangle.h&quot; namespace &quot;shapes&quot;:
    cdef cppclass Triangle:
        Triangle() except +
        Triangle(double, double, double, double, double, double) except +
        double x0, y0, x1, y1, x2, y2
        double getArea()


    cdef cppclass Rectangle:
        Rectangle() except +
        Rectangle(double, double, double, double) except +
        double x0, y0, x1, y1
        double getArea()
        void getSize(double* width, double* height)
        void move(double, double)
        Triangle get_lower_triangle()



cdef class PyTriangle:
    cdef Triangle c_tri
    def __cinit__(self, double x0, double y0, double x1, double y1, double x2, double y2):
        self.c_tri = Triangle(x0, y0, x1, y1, x2, y2)
    def get_area(self):
        return self.c_tri.getArea()


cdef class PyRectangle:
    cdef Rectangle c_rect      # hold a C++ instance which we&#39;re wrapping
    def __cinit__(self, double x0, double y0, double x1, double y1):
        self.c_rect = Rectangle(x0, y0, x1, y1)
    def get_area(self):
        return self.c_rect.getArea()
    def get_size(self):
        cdef double width, height
        self.c_rect.getSize(&amp;width, &amp;height)
        return width, height
    def move(self, dx, dy):
        self.c_rect.move(dx, dy)
    def get_lower_triangle(self):
        return PyTriangle(self.c_rect.x0, self.c_rect.y0,
                          self.c_rect.x1, self.c_rect.y0,
                          self.c_rect.x1, self.c_rect.y1)
</code></pre>
<p>rect.pyx文件改动比较大。除了增加了PyTriangle类之外，还在PyRectangle类中中加了一个函数<strong>get_lower_triangle(self)</strong>，这个函数是原本C++类中没有的。从这一点可以更直观的理解我通过前一个例子体会到的三点收获：</p>
<ol>
<li>Cython连接C++的函数是是通过Python类的函数-&gt;cppclass-&gt;C++函数实现的。</li>
<li>Python类的函数名称不一定要和C++函数名称一直，只要接口定义好到底调用哪个函数就行。</li>
<li>Python类的函数数目也不一定要和C++函数一致，只需要保证Python想调用的C++函数已经定义且能够找到就行。</li>
</ol>
<h2 id="setup-py文件"><a href="#setup-py文件" class="headerlink" title="setup.py文件"></a>setup.py文件</h2><p>setup.py:</p>
<pre><code class="python">from distutils.core import setup
from Cython.Build import cythonize

setup(ext_modules = cythonize(
           &quot;rect.pyx&quot;,                 # our Cython source
           sources=[&quot;Rectangle.cpp&quot;],  # additional source file(s)
           language=&quot;c++&quot;,             # generate C++ code
      ))
</code></pre>
<p>这个文件的内容没有发生变化。</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>编译方法和<a href="https://zxkjack123.github.io/cython/cython-hello-world/">Cython调用C++函数例子</a>中一样。</p>
<h2 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h2><p>修改<strong>run.py</strong>脚本：</p>
<pre><code class="python">import rect
#print(rect.PyRectangle(0, 0, 1, 2).get_area())

#print(rect.PyTriangle(0, 0, 0, 1, 1, 0).get_area())

rect1 = rect.PyRectangle(0.0, 0.0, 1.0, 2.0)
tri1 = rect1.get_lower_triangle()
print(type(tri1))
print(tri1.get_area())
</code></pre>
<p>运行后输出结果：</p>
<pre><code>&lt;type &#39;rect.PyTriangle&#39;&gt;
1.0
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我想返回的是Python中用的类的对象，不需要在C++类中也写一个一样的函数然后再转换。</p>
]]></content>
      
        <categories>
            
            <category> Cython </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cython </tag>
            
            <tag> Object </tag>
            
            <tag> class </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[日语句子成分的名词化]]></title>
      <url>/Japanese/nonize/</url>
      <content type="html"><![CDATA[<p>日语句子中，名词是很重要的一个成分。日语中存在很多将原本不是名词的成分转化成为可以当作名词使用的表达方式。</p>
<p>如果把句子成分的两个属性：词性和意义分开来看，句子成分的化形式就是将这个成分的词性变成名词的过程。这个过程有时侯还会为这个句子成分增加一层额外的意义。比如将动词或者小句转化为名词词性的<strong>の</strong>和将一类形转化为名词的<strong>さ</strong>，他们都没有给词汇本身增加额外的含义。而其他的很多词，比如<strong>ほう</strong>，<strong>ため</strong>等等，则给原来的句子或核心词汇增加了额外的含义。我感觉这额外增加的含义，就是<strong>ほう</strong>，<strong>ため</strong>他们本身作为名词的含义。也就是说，<strong>ほう</strong>，<strong>ため</strong>这些词并不是单纯的将动词或小句转化为名词的句子，反而更像是其前面的动词或者小句是<strong>ほう</strong>，<strong>ため</strong>的定语，用来修饰<strong>ほう</strong>，<strong>ため</strong>这些名词的定语。</p>
<p>特别是当我们把这些假名对应的汉字标注出来的时候，能够更加直观的理解到这其中增加的含义。</p>
<p>下面是在《标准日本语》（初级）课本中包含的一些将句子成分名词化的例子。</p>
<ul>
<li><strong>こと</strong> <a href="http://jisho.org/search/%E3%81%93%E3%81%A8" target="_blank" rel="noopener">日本語：事, こと</a><ul>
<li>第20課：<strong>动(基本形)</strong>+<strong>ことができます</strong>，表示能力。「例」:私の趣味は切手を<strong>集めること</strong>です。</li>
<li>第21課：<strong>动(た形)</strong>+<strong>ことがあります</strong>，表示过去经历。「例」：私はすき焼きを<strong>食べたことがあります</strong>。</li>
<li>第31課：<strong>动(基本形/ない形)</strong>+<strong>ことがあります</strong>，表示有时会发生某种事态，<em>与21课的句型是完全不同的句型</em>。「例」：たまに朝ご飯を食<strong>べないことがあります</strong>。</li>
<li>第32課：<strong>动(基本形/ない形)</strong>+<strong>ことにします/ことにしました</strong>，表示说话人自己决定实施某种行为时使用。「例」：明日から毎日<strong>運動することにします</strong>。</li>
<li>第32課：<strong>动(基本形/ない形)</strong>+<strong>ことになりました</strong>，表示由于某种外在的原因导致形成了某种决定。「例」：来月から給料が<strong>上がることになりました</strong>。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>の</strong><ul>
<li>第26课：<strong>小句(动词简体形)</strong>+<strong>の</strong>，使小句名词化，表示<strong>做某动作</strong>的意思。「例」：<strong>自転車に二人で乗るの</strong>は危ないです。</li>
<li>第36課：<strong>动(基本形)</strong>+<strong>の</strong>+<strong>に</strong>,表示用途和基准。「例」：この写真はパスポートを<strong>申請するのに</strong>使います。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>ほう</strong>　<a href="http://jisho.org/search/%E3%81%BB%E3%81%86" target="_blank" rel="noopener">日本語：方、ほう</a><ul>
<li>第21課：<strong>动(た形)</strong>+<strong>ほう</strong>，用于在两种事物中进行选择。「例」：もっと野菜を<strong>食べたほう</strong>がいいですよ。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>そう</strong>    （很奇怪，没找到对应汉字，而<a href="http://jisho.org/search/%E3%81%9D%E3%81%86" target="_blank" rel="noopener">そう</a>怎么查了是个动词？)<ul>
<li>第33課： <strong>动/形</strong>+<strong>そう</strong>，事物样态或者推测。动词使用ます连用形加そう，一类形去い加そう，二类形直接加そう。「例」：<strong>おいしそう</strong>なケーキですね。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>ため</strong> <a href="http://jisho.org/search/%E3%81%9F%E3%82%81" target="_blank" rel="noopener">日本語：為、ため</a><ul>
<li><strong>小句1(基本形)+ために, 小句2</strong>，小句1是小句2的<strong>目的</strong>。「例」：<strong>日本に留学するために</strong>、お金をためています。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>よう</strong>　<a href="http://jisho.org/search/%E3%82%88%E3%81%86" target="_blank" rel="noopener">日本語：様、よう</a><ul>
<li>第38課：<strong>小句(基本形/ない形)</strong>+<strong>よう</strong>，表示状态。「例」：<strong>よく見えるように</strong>、大きく書きました。  </li>
<li>第44課：<strong>小句(简体形)</strong>+<strong>ようです</strong>，表示根据说话人感知的某种情况进行推测。「例」：玄関のところにだれか<strong>いるようです</strong>。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>まま</strong> <a href="http://jisho.org/search/まま" target="_blank" rel="noopener">日本語：儘、侭、まま</a><ul>
<li>第42課：<strong>小句1(动词た形/ない形)</strong>+<strong>まま</strong>,<strong>小句2</strong>，表示将理应改变的状态保持着去进行另外的动作。「例」：テレビをつけたまま、出かけてしまいました。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>はず</strong> <a href="http://jisho.org/search/はず" target="_blank" rel="noopener">日本語：筈、はず</a> <ul>
<li>第42課：<strong>小句(简体形)</strong>+<strong>はずです</strong>，表示根据某种理由做出某种推断。「例」：会議は五時までですから、もうすぐ<strong>終わるはずです</strong>。 </li>
</ul>
</li>
</ul>
<ul>
<li><strong>さ</strong><ul>
<li>第44課：<strong>一类形</strong>+<strong>さ</strong>，构成一种表示某种状态的名词。构成方式是一类形词尾的<strong>い</strong>换成<strong>さ</strong>。「例」：この<strong>暑さ</strong>はいつまで続くんでしょう。</li>
</ul>
</li>
</ul>
<ul>
<li>动词ます形去ます<ul>
<li>第43課：部分动词的ます形去ます之后，形成名词。「例」：休み、申し出</li>
</ul>
</li>
</ul>
<p>つづく…</p>
]]></content>
      
        <categories>
            
            <category> Japanese </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Japanese </tag>
            
            <tag> 日语 </tag>
            
            <tag> 日本語 </tag>
            
            <tag> 名词化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[日语动词变形学习]]></title>
      <url>/Japanese/verb-conjugation/</url>
      <content type="html"><![CDATA[<p>因为很喜欢日语动漫，所以我现在在学习日语。网上找了一些日语入门的攻略，觉得这篇<a href="你有什么相见恨晚的日语学习方法？ - Hayami的回答 - 知乎
https://www.zhihu.com/question/26939890/answer/36393970">大神的日语学习方法，10天入门，2个月达到N3水平，7个月突破N1，颠覆了我学习语言的思维</a>写的很好，我非常认同里面的内容。因此我也正在按照这个攻略进行入门阶段的学习，现在正学习到新编日语初级下册。学习的重点是掌握日语动词的变形。</p>
<p>这两天刚刚学习到动词的使役被动态，算是基本接触到了日语动词所有的变形了。在巩固学习日语动词变形的过程中，又发现了一些其他的很好的资源。</p>
<ol>
<li><p>日语老师宵寒在其知乎日语学习专栏中发表的文章<a href="https://zhuanlan.zhihu.com/p/23853643" target="_blank" rel="noopener">巴拉拉变身！！！史上最全日语动词变形大汇总</a>中总结了日语的各种变形的规律。<br><img src="https://pic2.zhimg.com/v2-026133e770956e146eb0a07e9dd46f0b_r.jpg" alt="日语变形树形图"></p>
</li>
<li><p>李特务在知乎的<a href="你有什么相见恨晚的日语学习方法？ - 李特务的回答 - 知乎
https://www.zhihu.com/question/26939890/answer/34763273">回答</a>中给出的一张动词或用练习表格：<img src="https://pic4.zhimg.com/8a902b350a7b819c1b9eb9647d130e06_r.jpg" alt="动词活用练习表格"></p>
</li>
</ol>
<p>我之前也想按照表格的形式来练习日语动词变形，但是发现这样有一些缺点：</p>
<ol>
<li>表格的连续性导致，在一列中不需要怎么动脑，按五十音图朝下读就出来了，动词变形效果不佳</li>
<li>检查答案不方便，自己错了都不容易发现</li>
<li>练习到的动词有限。对表上的这些动词的确是非常熟悉了，但是碰到不在表格内的动词就比较慌。最不好的是，碰到表格外的动词，变形前居然会先联想到对应的表格内的动词，用表格内动词的变形规律，再去对应到表格外动词的变形。这无疑大大降低了变形的速度</li>
<li>动词的联系频率不变。对自己常出错的单词和变形形式应该通过增加联系次数来巩固，而对于已经掌握的动词变形形式，就应该降低练习次数。使用表格练习法，显然无法做到动态的调整动词变形练习次数。</li>
</ol>
<p>因此，我自己写了一个练习动词变形的<a href="https://github.com/zxkjack123/JapaneseVerbPractice" target="_blank" rel="noopener">小软件</a>。<br>这个小软件实现的功能是：随机生成一些动词练习的题目，由练习者输入答案，并反馈和记录练习结果。<br>小软件具备以下特性：</p>
<ol>
<li>可以自己定义想练习的动词。比如只练习新标日初级上的动词</li>
<li>可以自己定义想联系的变形形式。比如只练习ます形，て形和た形。（在Japanese_verb_form.jvp中指定即可)</li>
<li>错误的及时反馈。你输错答案的话，它立马告诉你你错了，并会告诉你正确答案。</li>
<li>动态调整动词变形练习频率。对于你犯错的动词变形，它在以后出现的概率会大大增加。对于你出错的动词变形，它在以后出现的频率会降低。</li>
</ol>
<p>在练习动词变形的时候，我经常把可能态和假定形搞混，被动和使役搞混。因此我觉得有必要再找找方法让这些变形规律更好记忆一些。先总结一个动词变形涉及到的表格(て形和た形规律不同）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">あ</th>
<th style="text-align:center">い</th>
<th style="text-align:center">う</th>
<th style="text-align:center">え</th>
<th style="text-align:center">お</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ない形</td>
<td style="text-align:center">ます形</td>
<td style="text-align:center">字典形</td>
<td style="text-align:center">命令形</td>
<td style="text-align:center">意志形</td>
</tr>
<tr>
<td style="text-align:center">被动态</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">假定形</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">使役态</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">可能态</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">使役被动态</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> Japanese </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Japanese </tag>
            
            <tag> 日语 </tag>
            
            <tag> 日本語 </tag>
            
            <tag> verb </tag>
            
            <tag> 动词 </tag>
            
            <tag> 動詞 </tag>
            
            <tag> conjugation </tag>
            
            <tag> 变形 </tag>
            
            <tag> 活用 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[日语词汇的修饰方法]]></title>
      <url>/Japanese/words_modifier/</url>
      <content type="html"><![CDATA[<p>最近开始学习《标准日本语》初级下册。在学习第25课《これは明日会議で使う資料です》的时候，语法解释部分总结了动词，动词小句后接名词的用法关系。我发现动词小句修饰名词时，结尾的动词形式和普通动词修饰名词一样。同样，一类形容词结尾的小句其形容词形式跟普通一类形容词修饰名词一样；二类形容词及名词同理。就是说，小句的句法使用形式和小句的结尾词的形式一样即可。</p>
<p>那么，掌握最小单位的修饰形式就可以了。具体形式包括：</p>
<ol>
<li>动词修饰名词：<strong>动(简体形)</strong>+<strong>名</strong></li>
<li>一类形修饰名词：<strong>一类形</strong>+<strong>名</strong></li>
<li>二类形修饰名词：<strong>二类形</strong>+<strong>な</strong>+<strong>名</strong></li>
<li>名词修饰名词：<strong>名</strong>+<strong>の</strong>+<strong>名</strong></li>
</ol>
<p>同理，不同类型的词汇后面连接动词时，也有相应的比较固定的形式。我现在的学习程度还太浅，不知道这种形式能否算作<strong>修饰</strong>动词，为了避免错误，这里只称之为<strong>后接</strong>动词。形容词和名词后不能直接接动词，需要转化为副词来后接动词。具体形式包括：</p>
<ol>
<li>动词转化为副词后接动词：不知道有没有这个，为了形式对称，先占个位置</li>
<li>一类形转化为副词后接动词：<strong>一类形词尾い变く</strong>+<strong>动</strong></li>
<li>二类形转化为副词后接名词：<strong>二类形</strong>+<strong>に</strong>+<strong>动</strong></li>
<li>名词转化为副词后接名词：<strong>名</strong>+<strong>に</strong>+<strong>动</strong></li>
</ol>
<p>第18课的课文提供了非常好的例子：</p>
<ol>
<li>携帯電話は　とても　<strong>小さく</strong>　なりました。　(一类形变副词后接动词）</li>
<li>テレビの　音を　<strong>大きく</strong>　します。 (一类形变副词后接动词)</li>
<li>息子は　<strong>医者に</strong>　なりました。 (名词变副词后接动词)</li>
<li>部屋を　<strong>きれいに</strong>　して　ください。　(二类形容词变副词后接动词)</li>
</ol>
<p>暂时没有发现名词用来修饰形容词的案例，也没有发现动词修饰形容词，名词或动词的案例。不清楚是否是因为我学到的内容还太少，暂时不做总结，待以后完善。</p>
]]></content>
      
        <categories>
            
            <category> Japanese </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Japanese </tag>
            
            <tag> 日语 </tag>
            
            <tag> 日本語 </tag>
            
            <tag> modifier </tag>
            
            <tag> 修饰语 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Cython调用C++函数例子]]></title>
      <url>/cython/cython-hello-world/</url>
      <content type="html"><![CDATA[<p>最近的的科研工作涉及到Cython的应用。以前没有接触过Cython,对这个基本不了解。如果不涉及到代码接口的改变，那么我可以学习前辈们的代码，照葫芦画瓢来改代码。可是那样的代码不够简介美观，Pull Request的Reviewer指出代码接口需要调整简化。</p>
<p>没办法，只能硬着头皮改。然而前辈们的代码中没有找到合适的参照，自己假象着改几下结果错误越來越多。不能像无头苍蝇一样改了，必须得学会Cython的基础使用方法。</p>
<p>我需要实现的功能是：有一个C++的程序，写一个Cython的接口，在python中调用C++中的函数。参考相关的<a href="http://cython.readthedocs.io/en/latest/src/userguide/wrapping_CPlusPlus.html#create-cython-wrapper-class" target="_blank" rel="noopener">官方文档</a>，这是一个简单的几何方面的库。按照官方文档走，结果还是走了不少弯路，有写东西官方文档上也没有写的很详细。</p>
<p>下面就将我学习这个例子的过程及需要注意的细节总结一下。</p>
<h2 id="C-代码部分"><a href="#C-代码部分" class="headerlink" title="C++代码部分"></a>C++代码部分</h2><h3 id="h文件"><a href="#h文件" class="headerlink" title="h文件"></a>h文件</h3><pre><code class="C++">namespace shapes {
    class Rectangle {
    public:
        int x0, y0, x1, y1;
        Rectangle();
        Rectangle(int x0, int y0, int x1, int y1);
        ~Rectangle();
        int getArea();
        void getSize(int* width, int* height);
        void move(int dx, int dy);
    };
}
</code></pre>
<h3 id="cpp文件"><a href="#cpp文件" class="headerlink" title="cpp文件"></a>cpp文件</h3><pre><code class="C++">#include &quot;Rectangle.h&quot;

namespace shapes {

  Rectangle::Rectangle() { }

    Rectangle::Rectangle(int X0, int Y0, int X1, int Y1) {
        x0 = X0;
        y0 = Y0;
        x1 = X1;
        y1 = Y1;
    }

    Rectangle::~Rectangle() { }

    int Rectangle::getArea() {
        return (x1 - x0) * (y1 - y0);
    }

    void Rectangle::getSize(int *width, int *height) {
        (*width) = x1 - x0;
        (*height) = y1 - y0;
    }

    void Rectangle::move(int dx, int dy) {
        x0 += dx;
        y0 += dy;
        x1 += dx;
        y1 += dy;
    }

}
</code></pre>
<h2 id="pyx文件"><a href="#pyx文件" class="headerlink" title="pyx文件"></a>pyx文件</h2><pre><code class="python">cdef extern from &quot;Rectangle.h&quot; namespace &quot;shapes&quot;:
    cdef cppclass Rectangle:
        Rectangle() except +
        Rectangle(int, int, int, int) except +
        int x0, y0, x1, y1
        int getArea()
        void getSize(int* width, int* height)
        void move(int, int)

cdef class PyRectangle:
    cdef Rectangle c_rect      # hold a C++ instance which we&#39;re wrapping
    def __cinit__(self, int x0, int y0, int x1, int y1):
        self.c_rect = Rectangle(x0, y0, x1, y1)
    def get_area(self):
        return self.c_rect.getArea()
    def get_size(self):
        cdef int width, height
        self.c_rect.getSize(&amp;width, &amp;height)
        return width, height
    def move(self, dx, dy):
        self.c_rect.move(dx, dy)
</code></pre>
<h2 id="setup-py文件"><a href="#setup-py文件" class="headerlink" title="setup.py文件"></a>setup.py文件</h2><pre><code class="python">from distutils.core import setup
from Cython.Build import cythonize

setup(ext_modules = cythonize(
           &quot;rect.pyx&quot;,                 # our Cython source
           sources=[&quot;Rectangle.cpp&quot;],  # additional source file(s)
           language=&quot;c++&quot;,             # generate C++ code
      ))
</code></pre>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>前面的文件内容在官方文档上写的还算清楚，但编译和使用部分，官方文档写的就很不清楚了。尤其是官方文档这里没有介绍编译cpp文件，只说不链接这个东西会出现undefine symbol的错误。这部分内容参考了<a href="https://stackoverflow.com/questions/28366147/how-can-i-manually-compile-cython-code-that-uses-c" target="_blank" rel="noopener">这里</a>。</p>
<h3 id="编译C-文件"><a href="#编译C-文件" class="headerlink" title="编译C++文件"></a>编译C++文件</h3><p>编译C++文件生成.o文件，C++ Objects在这个文件里面。</p>
<pre><code class="bash">$ gcc -c Rectangle.cpp
</code></pre>
<h3 id="运行setup"><a href="#运行setup" class="headerlink" title="运行setup"></a>运行setup</h3><pre><code class="bash">$ python setup.py build_ext --inplace
</code></pre>
<p>这一步会生成<strong>rect.so</strong>，但是这个文件暂时还不能使用，在python中import rect的话会出现<strong>ImportError: ./rect.so: undefined symbol</strong>错误。</p>
<h3 id="链接rect-so与Rectangle-o"><a href="#链接rect-so与Rectangle-o" class="headerlink" title="链接rect.so与Rectangle.o"></a>链接rect.so与Rectangle.o</h3><pre><code class="bash">$ gcc -shared -fPIC -I/usr/include/python2.7 rect.cpp Rectangle.o -lstdc++ -o rect.so
</code></pre>
<h2 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h2><p>下一个脚本<strong>run.py</strong>，放入如下内容：</p>
<pre><code class="python">import rect
print(rect.PyRectangle(0, 0, 1, 2).get_area())
</code></pre>
<p>运行该脚本，如果流程正确，应该会得到输出：</p>
<pre><code>2
</code></pre><h2 id="总结反思"><a href="#总结反思" class="headerlink" title="总结反思"></a>总结反思</h2><p>通过这个例子，不难看出：</p>
<ol>
<li>Cython连接C++的函数是是通过Python类的函数-&gt;cppclass-&gt;C++函数实现的。</li>
<li>Python类的函数名称不一定要和C++函数名称一直，只要接口定义好到底调用哪个函数就行。</li>
<li>Python类的函数数目也不一定要和C++函数一致，只需要保证Python想调用的C++函数已经定义且能够找到就行。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Cython </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cython </tag>
            
            <tag> Hello world </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用PyNE制作材料库]]></title>
      <url>/neutronics/make-pyne-material-lib/</url>
      <content type="html"><![CDATA[<p>在使用DAGMC进行输运计算的时候，其几何文件中，已经通过trelis定义了材料名称和密度，但并没有定义这些材料的具体组成成分。在进行计算之前，需要制作相应的材料数据库，把材料数据写入到h5文件中，再跟几何文件整合起来。这样，DAGMC就知道这个栅元的材料成分了。</p>
<p>针对不同的问题规模，可以采用不同的形式来制作材料库。比如简单的问题，只需要几种不复杂的材料时，我们可以直接在python脚本内编辑材料成分，然后写入材料库。对于涉及材料比较多的问题，可以通过提前准备材料数据库文件（即将各种材料以一定格式提前保存在电脑中，再通过python脚本读取材料文件格式化的制作材料数据库）。或者直接提前准备包含自己会用到的h5材料数据库。</p>
<h2 id="简单数据库制作"><a href="#简单数据库制作" class="headerlink" title="简单数据库制作"></a>简单数据库制作</h2><p>对于几何简单，涉及材料较少(少于5个材料)的计算任务，直接在python脚本中调用pyne的材料库写就行了。</p>
<p>定义材料时，我们需要制定材料的以下信息：</p>
<ol>
<li>名称：和trelis中group name对应的字符串</li>
<li>密度：材料密度</li>
<li>核素组成：材料的具体成分</li>
</ol>
<p>我们可以用多种方式来定义材料的组成成分，详细说明可以参考<a href="http://pyne.io/tutorial/02.html" target="_blank" rel="noopener">官方文档</a>。比如下面三种常用方式：</p>
<ol>
<li>通过核素的核子密度比例(atom fraction)，可以不归一化</li>
<li>通过核素的质量份额(mass fraction)，可以不归一化</li>
<li>通过元素的质量份额，然后expand元素</li>
</ol>
<p>比如下面的文件定义了<strong>Water</strong>，<strong>BoronCarbide</strong>和<strong>Steel</strong>三种材料并将材料写入到材料库<strong>example_material_lib.h5</strong>中。</p>
<pre><code class="python">#!/usr/bin/python
#
from pyne.material import Material, MaterialLibrary

print &quot;Welcome!&quot;
mat_lib = MaterialLibrary()

# define a simple water since O-18 not in mcnp xs libs
watervec = {10010:2,80160:1} # simple water
water = Material()
water.density = 1.0
water.from_atom_frac(watervec)

# define b4c
b4c = Material()
b4c.from_atom_frac({&#39;B&#39;:4,&#39;C&#39;:1})
b4c.density = 2.54
b4c = b4c.expand_elements()

# define steel
steel = Material({&#39;Fe&#39;:0.655,&#39;Cr&#39;:0.170,&#39;Ni&#39;:0.120,&#39;Mo&#39;: 0.025,&#39;Mn&#39;: 0.02, &#39;Si&#39;:.01},density=7.92)
steel = steel.expand_elements()

# put materials into mat_lib
mat_lib[&quot;Water&quot;] = water
mat_lib[&quot;BoronCarbide&quot;] = b4c
mat_lib[&quot;Steel&quot;] = steel

# write into hdf5 file
mat_lib.write_hdf5(&quot;example_material_lib.h5&quot;)
#
print &quot;All done!&quot;
</code></pre>
<p>此例子中，定义<strong>Water</strong>时用材料的核素个数比例来定义的材料。在定义<strong>BoronCarbide</strong>时使用材料的元素比例来定义。在定义<strong>Steel</strong>时使用的材料的元素质量份额来定义。</p>
<h2 id="格式化数据库制作"><a href="#格式化数据库制作" class="headerlink" title="格式化数据库制作"></a>格式化数据库制作</h2><p>对于涉及材料比较多，材料成分比较复杂的模型，直接用python脚本来定义每种材料就会非常麻烦了，而且不利于材料的更新，维护与阅读。</p>
<p>对于原本是使用其他蒙特卡罗软件的人，可能已经为其使用的软件准备了一套材料数据库，要是让他们再为其他软件单独准备一套数据库，工作量又大，又容易出错。这时使用脚本将其他格式的材料转换为pyne的材料定义方式是更好的选择。</p>
<p>因此，格式化数据库制作的过程，就是指将原本以其他媒介（如excel, 文本文件，hdf5文件等）以其他格式（如成分表格，MCNP格式等）存放的材料信息转化为pyne识别的，可以用于DAGMC计算的材料数据库的过程。</p>
<p>万变不离其宗，不论是什么媒介什么格式的方式，都是通过读取材料的名称，密度和材料组成成分进而根据pyne的格式来定义材料数据库。</p>
]]></content>
      
        <categories>
            
            <category> neutronics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PyNE </tag>
            
            <tag> material </tag>
            
            <tag> library </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于倾听的一些想法]]></title>
      <url>/life/why-listen/</url>
      <content type="html"><![CDATA[<p>以前为了想让自己的人际关系变得更好，交更多朋友，读过一些关于倾听的艺术的书。我学了一些倾听别人的皮毛技巧，比如不打断别人的话，不要去指导别人怎么做，不要用自己的经历去佐证或是反驳地方等等。我需要做的只是认认真真的聆听，做一个倾听者，做一些简单的反馈告诉地方我在认真的听就够了。</p>
<p>但我现在觉得单纯做一个倾听者并没有意义。因为每个人都只在乎自己的想法，只在乎自己的感受。我们希望别人理解自己，其实更多的是希望对方做出符合自己想法的事情，或者说至少尊重自己的想法，不去阻碍自己。</p>
<p>没有人真正在乎另一个人的内心想法，即便是恋人这种亲密关系也不一定。我生活中实际发生的故事验证了这一点。我现在独自一人在外学习，和女朋友异国。虽然每天都会在电话或视频里聊不少东西，但我依然感觉到孤独感。<br>今天我们聊到了这个话题，有了下面的对话：</p>
<p><em>我：我有这种孤独的感觉，自己一个人的时候会想各种东西，有时心里很乱，想找个人述说，但却没有人听。</em></p>
<p><em>女朋友：你可以跟我说啊，我愿意听。</em></p>
<p><em>我：可是我说我内心感受的时候，你时不时就打断我，或者指导我该怎么做，或者就着话题扯到别的事情上，根本没有让我说完话。</em></p>
<p><em>女朋友：好像是哦，对不起</em></p>
<p><em>我：哎，其实我也一样，你说你的事情的时候，我也经常心不在焉，做别的事了，只是简单的嗯嗯啊哦的回应一下。就像你之前告诉我你知乎专栏上有两篇文章，但我连题目都没看。我告诉你我在写博客，让你点进来看一下，你也就点了一下，没有认真读内容。</em></p>
<p><em>女朋友：嗯，的确是，我就点了标题粗略看了下。</em></p>
<p><em>我：我们是男女朋友之间都这样，那跟其他人估计更别提了。</em></p>
<p>我和我的女朋友都承认自己并没有真正的关心对方的内心想法与感受，但我们还是在倾听。</p>
<p>我想起一个故事：邹忌讽齐王纳谏。“吾妻之美我者，私我也；妾之美我者，畏我也；客之美我者，欲有求于我也”。大家都爱听自己喜欢的话，爱听符合自己利益的意见。</p>
<p>我为什么要聆听别人的想法呢？我和其他人一样，并不真正关心另一个人的感受，我需要把聆听当作一种手段，从其他人那里获取信息，做到知己知彼，用来包装对自己有利的建议。</p>
<p>为什么别人会听我的呢？不，不会，别人不会听我的，别人听的是符合他们想法利益的事情。不符合他们利益的话，那些他们不想听的话，他们一句也听不进去。我要做的不过是把对我有利的事情中对他们也有利的那些关键点整理出来告他们，那些是他们愿意听的东西。双赢。</p>
<p>同时，我也应该像邹忌那样审视我所听到的一切。由此观之，能真诚相待的人，这一辈子估计遇不到多少个，每一个多应该珍惜。而且二十岁以后遇到的朋友里面，怕是很难出现真诚相待的人了。</p>
]]></content>
      
        <categories>
            
            <category> life </category>
            
        </categories>
        
        
        <tags>
            
            <tag> listening </tag>
            
            <tag> 倾听 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[跳槽是最好的涨薪方式？]]></title>
      <url>/career/get-higher-salary/</url>
      <content type="html"><![CDATA[<p>最近几年经常听说在一个企业干了几年的老员工工资还不如新入职的员工。Sean Ye在他的知乎专栏<a href="https://zhuanlan.zhihu.com/p/32894248" target="_blank" rel="noopener">年终涨薪的水，到底有多深</a>中将了这种现象形成的原因，也将到了对于那些认为自己应该获得更高工资的人的一个策略：跳槽。去外部寻求更好的机会，让自己获得市场价的工资。</p>
<p>我个人非常认同Sean Ye的观点。我本身就比较喜欢每隔一段时间换一个地方，而这也正好能够满足涨薪的需求。</p>
<p>但同时也还有一个担忧：跳槽对于涨薪的确是良方，但对于升职和长久的职业发展是否有利？这个还需要我进行多方面的思考。</p>
<p>感谢<a href="https://www.zhihu.com/people/sean-yenan/activities" target="_blank" rel="noopener">Sean Ye</a>的专栏。下面是Sean Ye的专栏和公众号信息：<br><img src="https://pic2.zhimg.com/80/v2-6638ae55d17d9680b3a6cba9e6dbebd5_hd.jpg" alt="Sean Ye"></p>
]]></content>
      
        <categories>
            
            <category> career </category>
            
        </categories>
        
        
        <tags>
            
            <tag> salary increase </tag>
            
            <tag> 涨薪 </tag>
            
            <tag> change jobs </tag>
            
            <tag> 跳槽 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的需求层次与努力方向]]></title>
      <url>/life/essential-skill/</url>
      <content type="html"><![CDATA[<p>以前上大学的时候，有上过职业规划之类的课，政治课上也有讨论过人生规划之类的问题，不过当时根本没有认真思考过这个问题，只想着老师快点下课。 </p>
<p>最近到国外访学中，每天有5个小时以上的时间是独处的，反而开始想这些问题。我想要一个怎么的人生，我该怎样去实现它？</p>
<p>经济基础决定上层建筑。我在社会上处在什么位置，现阶段我人生的主要矛盾是什么？我该怎么样更上一层？<a href="https://zh.wikipedia.org/wiki/%E9%9C%80%E6%B1%82%E5%B1%82%E6%AC%A1%E7%90%86%E8%AE%BA" target="_blank" rel="noopener">马斯洛需求层次理论</a>是一个常用来描述这个问题的理论。我觉得这个理论用在我身上也很合适。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b5/Maslows-hierarchy-of-needs-zh.svg/512px-Maslows-hierarchy-of-needs-zh.svg.png" alt="马斯洛需求层次理论"></p>
<p>我现在不需要为<strong>生理需求</strong>层面的食物，水，空气和睡眠而操心。我担心最多的是：</p>
<ol>
<li>毕业了找不到好工作，工资不高怎么办</li>
<li>买不起房子结不起婚怎么办</li>
<li>即便结婚了，养不起孩子怎么办</li>
</ol>
<p>这些担忧的核心，也可以归结为一个方面：<strong>能否找到一个工资较高，福利待遇好的工作</strong>。这个工作必须要能够提供比较高的薪水。如果这个工作能够同时兼顾社交需求，尊重需求和自我实现需求，就更好了。</p>
<p>对我而言，要找到这样的工作，必须要具备一些核心技能，增加自己的不可替代性。这些技能需要具备以下特征：</p>
<ol>
<li>能够增加自己的工作机会</li>
<li>能够持续发展，终身学习的技能</li>
<li>有门槛，上限高，水平不同是能够比较容易区分</li>
<li>我必须掌握的好。</li>
</ol>
<p>这些技能还要能够持续发展。我的专业是核能科学与工程，但平时主要做的是模拟计算和数据处理与分析。对于我而言，在核能领域或是数据分析领域是最合适的工作领域。应该至少把这两个作为核心技能，同时，其他我能想到的重要的技能也需要发展。</p>
<ol>
<li>核能专业的知识与技能</li>
<li>数据分析的编程能力,重点发展：Python与C++</li>
<li>语言能力，英语需要进一步提升，再学习一门日语</li>
</ol>
]]></content>
      
        <categories>
            
            <category> life </category>
            
        </categories>
        
        
        <tags>
            
            <tag> needs </tag>
            
            <tag> 需求 </tag>
            
            <tag> hierarchy </tag>
            
            <tag> 层次 </tag>
            
            <tag> 核心技能 </tag>
            
            <tag> essential skill </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安装PyNE的开发版本]]></title>
      <url>/neutronics/pyne-developer-install/</url>
      <content type="html"><![CDATA[<h2 id="PyNE简介"><a href="#PyNE简介" class="headerlink" title="PyNE简介"></a>PyNE简介</h2><p><a href="http://pyne.io/" target="_blank" rel="noopener">PyNE</a> 是一系列计算核工程领域的工具组成的一个系统工具平台。</p>
<p>我是用PyNE配合DAGMC来进行停机剂量计算工作。现在正在进行一部分的改进工作，需要添加一部分代码，因此需要安装PyNE的开发版本。</p>
<h2 id="Ubuntu-16-04系统下安装PyNE开发者版本"><a href="#Ubuntu-16-04系统下安装PyNE开发者版本" class="headerlink" title="Ubuntu 16.04系统下安装PyNE开发者版本"></a>Ubuntu 16.04系统下安装PyNE开发者版本</h2><p>前段时间，我的系统因为一次partial upgrade而崩溃，所有工具都需要重新装。很多工具安装起来都很麻烦，会遇到各种各种的问题，所以借此机会把整个流程梳理一下，记录在这份文档中，方便以后再遇到类似情况，可以比较快捷的重装PyNE。</p>
<p>PyNE已经写了针对不同系统使用的<a href="https://github.com/pyne/install_scripts" target="_blank" rel="noopener">安装脚本</a>。比如我是Ubuntu 16.04的系统，就使用<code>ubuntu_16.04.sh</code>。在安装过程中,还会自动安装所依赖的软件。</p>
<p>但是，这个安装脚步是针对使用着的，对于开发者，尤其是需要使用DAGMC的开发者，不能直接使用这个脚本。</p>
<p>另外，现在PyNE最高支持MOAB 4.9.1 版，然而DAGMC需要使用MOAB 5.0版。也就是说，使用DAGMC的PyNE开发者需要在电脑上同时安装MOAB 4.9.1 和5.0版本。必须分别安装并设定，使用时还需要指定所使用库的路径。</p>
<h3 id="安装依赖软件"><a href="#安装依赖软件" class="headerlink" title="安装依赖软件"></a>安装依赖软件</h3><p>在<a href="https://github.com/pyne/install_scripts" target="_blank" rel="noopener">pyne/install_scripts</a>下找到<a href="https://github.com/pyne/install_scripts/blob/master/ubuntu_16.04.sh" target="_blank" rel="noopener"><strong>ubuntu_16.04.sh</strong></a>这个文件，其中的<em>package_list</em>就是安装pyne前需要安装的工具。使用下面的命令安装这些软件：</p>
<pre><code class="bash">sudo apt-get install software-properties-common python-software-properties wget \
             build-essential python-numpy python-scipy cython \
             python-nose git cmake vim emacs gfortran libblas-dev \
             liblapack-dev libhdf5-dev gfortran python-tables  \
             python-matplotlib python-jinja2 autoconf libtool
</code></pre>
<h3 id="安装MOAB4-9-1"><a href="#安装MOAB4-9-1" class="headerlink" title="安装MOAB4.9.1"></a>安装MOAB4.9.1</h3><p>按照下面的命令安装MOAB4.9.1（下面的命令将把MOAB4.9.1安装在<strong>$HOME/opt/MOAB4.9.1</strong>，如果要换文件家，改掉export MOAB_DIR的命令即可)。</p>
<pre><code class="bash">cd $HOME/opt
mkdir MOAB4.9.1
cd MOAB4.9.1
export MOAB_DIR=$HOME/opt/MOAB4.9.1
git clone --branch Version4.9.1 --single-branch https://bitbucket.org/fathomteam/moab moab-repo
cd moab-repo
autoreconf -fi
mkdir -p build
cd build
../configure --enable-shared --enable-dagmc --with-hdf5=/usr/lib/x86_64-linux-gnu/hdf5/serial --prefix=$MOAB_DIR
make
make install
echo &quot;export LD_LIBRARY_PATH=$MOAB_DIR/lib:\$LD_LIBRARY_PATH&quot; &gt;&gt; ~/.bashrc
echo &quot;export LIBRARY_PATH=$MOAB_DIR/lib:\$LIBRARY_PATH&quot; &gt;&gt; ~/.bashrc
echo &quot;export CPLUS_INCLUDE_PATH=$MOAB_DIR/include:\$CPLUS_INCLUDE_PATH&quot; &gt;&gt; ~/.bashrc
echo &quot;export C_INCLUDE_PATH=$MOAB_DIR/include:\$C_INCLUDE_PATH&quot; &gt;&gt; ~/.bashrc
source ~/.bashrc
</code></pre>
<h3 id="安装pytaps"><a href="#安装pytaps" class="headerlink" title="安装pytaps"></a>安装pytaps</h3><p>安装下面命令将pytaps安装在$HOME/opt文件夹下：</p>
<pre><code class="bash">cd $install_dir
wget https://pypi.python.org/packages/source/P/PyTAPS/PyTAPS-1.4.tar.gz
tar zxvf PyTAPS-1.4.tar.gz
rm PyTAPS-1.4.tar.gz
cd PyTAPS-1.4/
# export MOAB_DIR=$HOME/MOAB4.9.1
python setup.py --iMesh-path=$MOAB_DIR --without-iRel --without-iGeom install --user
</code></pre>
<h3 id="安装PyNE"><a href="#安装PyNE" class="headerlink" title="安装PyNE"></a>安装PyNE</h3><pre><code class="bash"># export MOAB_DIR=$HOME/opt/MOAB4.9.1
python setup.py install --user --hdf5=/usr/lib/x86_64-linux-gnu/hdf5/serial/ -DMOAB_LIBRARY=$MOAB_DIR/lib/libMOAB.so -DMOAB_INCLUDE_DIR=$MOAB_DIR/include
echo &quot;export PATH=$HOME/.local/bin:\$PATH&quot; &gt;&gt; ~/.bashrc
echo &quot;export LD_LIBRARY_PATH=$HOME/.local/lib:\$LD_LIBRARY_PATH&quot; &gt;&gt; ~/.bashrc
</code></pre>
<h4 id="核数据"><a href="#核数据" class="headerlink" title="核数据"></a>核数据</h4><pre><code class="bash">./scripts/nuc_data_make
</code></pre>
<p>2018年1月26日执行该操作时出现除零错误，下周复现问题并提交issue.</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>PyNE在开发过程中，功能性函数都配置了unit test进入pyne/tests问价夹下：</p>
<pre><code class="bash">nosetests test_xxx
</code></pre>
<h2 id="重新编译安装PyNE"><a href="#重新编译安装PyNE" class="headerlink" title="重新编译安装PyNE"></a>重新编译安装PyNE</h2><p>当开发者对原代码进行修改后，在提交Pull Request前，必须对代码进行测试。此时需要重新编译PyNE，然后进行测试。在重新编译PyNE前，必须将原来的安装文件清除掉，再重新编译。为了方便操作，将下面两条命名写入~/.bashrc中：</p>
<pre><code class="bash">echo &quot;alias pyne_build=&#39;python setup.py install --user --hdf5=/usr/lib/x86_64-linux-gnu/hdf5/serial/ -DMOAB_LIBRARY=$MOAB_DIR/lib/libMOAB.so -DMOAB_INCLUDE_DIR=$MOAB_DIR/include&#39;&quot; &gt;&gt; ~/.bashrc
$ echo &quot;alias pyne_clean=&#39;rm -rf $HOME/opt/pyne/build/ $HOME/.local/lib/python2.7/site-packages/pyne* $HOME/.local/lib/libpyne.so $HOME/opt/pyne/build_nuc_data&#39;&quot;
# source ~/.bashrc
</code></pre>
<p>之后需要重新编译PyNE的时候，只需要执行下面的命令即可：</p>
<pre><code class="bash">pyne_clean
pyne_build
</code></pre>
]]></content>
      
        <categories>
            
            <category> neutronics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> neutronics </tag>
            
            <tag> PyNE </tag>
            
            <tag> developer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[为什么写博客？为什么放到GitHub？]]></title>
      <url>/life/why-blog/</url>
      <content type="html"><![CDATA[<p>所有的记忆都会被时间冲淡，不论这件事情在当时是多么重要。</p>
<p>看过的书，里面的内容很快就忘了，只记得曾经看过某本书。思考过的事情，也只有在再次遇到类似的内容时才能想起自己曾经思考过，可是具体细节却已忘记。不记录下来，就会遗忘。</p>
<p>即便是记过的笔记，日后想翻看时，早已不知道放在哪里，更不论里面的内容。记录的东西如果没办法方便的查找和回顾，那也没有意义。</p>
<p>就连自己的过去，也会被自己忘记。</p>
<p>回忆自己小时候的样子，却只能想起零星的几件事情，而且对这些事情的记忆也回来越模糊。而且还有更可怕的事情，回忆以前，细节总是记不清的，然而总会下意识的“脑补”一些细节填充进去，一段时间后，我已无法分辨那些细节到底是否真实发生过。</p>
<p>另外，生活中我也时常会主动说一些谎言来掩护我当时的行为或言论。当有类似的情况需要撒谎时，为了保证谎言不被拆穿，我便会撒同样的慌，甚至杜撰出更多的细节来支撑这个谎言。以至于那个谎言已经几乎成为我过去的真实经历。</p>
<p>我已无法通过记忆来认识真实的自己了。因为真实的记忆被逐渐淡忘，下意识脑补出细节来补充，自己编纂出的谎言也混入记忆中。我的记忆慢慢的成为了我与外界交流的工具，可以用来和朋友吹逼，可以到知乎上分享故事，可以为自己的观点编造一些论据，也可以为自己的失败找一些理由。然而，它却没法再用来认识我自己。</p>
<p>我现在才二十来岁了，记忆仿佛已经不属于我自己。这让我感到害怕，有一种失去自我的感觉。我是怎样一步步发展成现在的我的？我想不起来的，而且越是思考这个问题，怕是又有更多的脑补细节填充到我的记忆中来了。我希望能有一个地方，能够记录下自己的轨迹，而且，即便被将来的我篡改了，也能留下清晰的痕迹。</p>
<p>用GitHub pages作为博客，可以记录下我每一个博客版本，正好满足我的需求。同时，这里也可以存放一些自己用得到的步骤比较复杂的东西的文档，是一个不错的博客工具。</p>
]]></content>
      
        <categories>
            
            <category> life </category>
            
        </categories>
        
        
        <tags>
            
            <tag> life </tag>
            
            <tag> 生活 </tag>
            
            <tag> memory </tag>
            
            <tag> 记忆 </tag>
            
            <tag> past </tag>
            
            <tag> 过去 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[博客迁移计划]]></title>
      <url>/life/first-blog-move/</url>
      <content type="html"><![CDATA[<p>一直在寻找一种适合自己的博客写作方式，在<a href="https://zhuanlan.zhihu.com/p/22191919" target="_blank" rel="noopener">知乎</a>上发现了这个方式，Hexo + github的写作方式。于是决定用这个来作为我以后的博客写作方式。</p>
<p>以前的博客是在网易博客上写的，东西也不多，就几篇内容，这个博客还可以<a href="http://zxkjack123.blog.163.com/#m=0&amp;t=0" target="_blank" rel="noopener">访问</a>，不过不打算更新了。选择更换的原因有：</p>
<ul>
<li><p>用了几次网易的博客，内容看着还行，但是登陆页面真的很渣，登陆自己的博客都很麻烦</p>
</li>
<li><p>没有办法做到离线提交，离线写博客</p>
</li>
<li><p>对公式之类的东西支持太差，和LaTeX内容兼容太差</p>
</li>
<li><p>在GitHub上搭建博客，远程异地同步很方便，我用GitHub也越来越多，很方便 </p>
</li>
</ul>
<p>特别是最近发现的了<a href="https://github.com/Moeditor/Moeditor" target="_blank" rel="noopener">moeditor</a>这个神器，用这个来写Markdown的内容非常方便，体验极佳。</p>
<p>一直想要一种好看的，跨平台的，方便同步，对公式和图片支持比较好的博客写作方式。现在，我感觉我的平台已经有了，剩下的就是坚持用博客记录自己的生活和学习了。</p>
]]></content>
      
        <categories>
            
            <category> life </category>
            
        </categories>
        
        
        <tags>
            
            <tag> life </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Chorme打开链接时在新窗口打开空白页问题]]></title>
      <url>/ubuntu/chrome-new-tab/</url>
      <content type="html"><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>我最近把自己的笔记本系统从Win10换到了Ubuntu 16.04。Chrome是我在Ubuntu系统上的默认浏览器。</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>安装Chrome完成打开之后使用都很正常，但就是有一个地方很蛋疼：<br>当你打开一个链接的时候，它会生成一个新的Chrome窗口(window)，然后在那个窗口显示的也是一个空白网页(tab)。</p>
<p>如果想让链接在原来已经打开的Chrome窗口中的一个新tab打开时，我必须使用以下操作：右击链接-&gt;拷贝链接地址-&gt;在空白网页粘贴链接</p>
<p>对于我这种经常需要从邮件里面打开链接的人来说，这种复杂的操作让我难以忍受。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>还好，国外已经有大佬帮我解决了这个<a href="https://askubuntu.com/questions/689449/external-links-are-opened-as-blank-tabs-in-new-browser-window-in-chrome" target="_blank" rel="noopener">问题</a>。</p>
<p>只需要打开</p>
<pre><code class="bash">$HOME/.local/share/applications/google-chrome.desktop
</code></pre>
<p>这个文件，<br>在</p>
<pre><code class="bash">Exec=/opt/google/chrome/chrome
</code></pre>
<p>这一行后面添加一个 <code>%U</code>再保存一下文件就OK了。</p>
<pre><code class="bash">Exec=/opt/google/chrome/chrome %U
</code></pre>
<p>我重装系统后又遇到了这个问题，结果忘了上次再哪而找的答案，结果又花了好久从找到。这次学聪明点，直接把答案搬运过来，翻译好，以后再遇到这个问题就不怕了。</p>
<p>我也遇到过要修改的那个文件名称不一致的情况，存在多个看着像那个文件但不是的文件。我索性直接把所有的相似的文件都加上了那个<code>%U</code>，这样问题解决。</p>
]]></content>
      
        <categories>
            
            <category> ubuntu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> chrome </tag>
            
            <tag> tab </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的Ubuntu装机必备软件]]></title>
      <url>/ubuntu/academic-tools/</url>
      <content type="html"><![CDATA[<h2 id="重装系统的恐怖回忆"><a href="#重装系统的恐怖回忆" class="headerlink" title="重装系统的恐怖回忆"></a>重装系统的恐怖回忆</h2><p>2017年的时候因为想在ubuntu上装个IE浏览器，然后网上找了一下，需要装个wine这个东西。然后一装，结果就把系统搞坏了，装任何软件或者卸载任何软件，都会莫名其妙的弹出一个窗口，告诉我在配置什么东西，下面一个“确定”按钮还点不了。<br>哎，我对ubuntu也不是特别熟，网上搜索了一下也没找到好的解决办法，心一横就把电脑重装系统了。</p>
<p>2018年1月23号，Ubuntu系统弹出提示，告诉我有更新，但是是什么partial update。心想着是系统提示的更新，就更新吧，确定，授权，更新，重启，整个流程都没有在意。然而当Boot Menu的开机页面蹦出来的时候，我傻眼了。什么鬼，进不去系统了！<br><img src="https://i.imgur.com/pZNBVCF.jpg" alt="开机页面"><br>我只能挥泪重装系统，好在最近的工作都同步在GitHub上，损失不大，只不过需要花点时间把东西都安装回来而已。</p>
<h2 id="额，具体要装哪些软件？"><a href="#额，具体要装哪些软件？" class="headerlink" title="额，具体要装哪些软件？"></a>额，具体要装哪些软件？</h2><p>在准备重装系统的时候，我意识到一个问题，我之前安装到底安装了哪些软件？</p>
<p>完了，我也记不清楚了。而且有些东西，安装之后又卸载，又装不同版本之类的，折腾来折腾去，压根不知道具体该装啥了。</p>
<p>只好凭借这回忆，把需要用的工具整理一番，将来万一系统又蹦了，也好用这个清单再一个个装回来。</p>
<ul>
<li>vim: 一个通用的文本编辑器。功能强大，配合各种插件，可以写各种代码。</li>
<li>Chrome: 浏览器，支持各种扩展应用和插件，比如google scholar插件，google dictionary插件，Todoist插件，Unblock boundary插件，Zotero插件，Ginger插件等。</li>
<li>Unblock boundary: 翻回国内看番剧的神器（需要购买会员），妈妈再也不用担心我在国外看不了bilibili了！</li>
<li>Lantern: 我一直用的科学上网利器。把~/.profile里面写上nohup /usr/bin/lantern &amp;，开机登陆就自动可以翻墙了，很方便。最近人在国外，暂时用不到。</li>
<li>Thunderbird: 收发邮件。即便是重装系统时本地文件全部清除后也不会丢失自己对邮件的处理记录，比如存档的邮件。点击<a href="https://zxkjack123.github.io/2018/01/25/ubuntu-thunderbird.html">这里</a>查看Thunderbird接收我常用邮箱的设置。</li>
<li>Mendeley: 科研文献管理软件，跨平台，能方便同步，能把文献生成bib文件，配合LaTeX写作很方便。不过最近已经转移到zotero了。</li>
<li>Zotero: 科研文献管理软件，跨平台，开源，方便同步。外导课题组使用zotero，我现在已经从mendeley切换到zotero了。</li>
<li>Tex live &amp; Texstudio: 很好用的LaTeX书写软件,配合GitHub保存一切书写记录和版本控制。LaTeX + GitHub写论文，版本控制很轻松，修改记录一直记录着。</li>
<li>kolourpaint4 &amp; Gimp: 画图用的。ubuntu平台没有adobe PS &amp; AI可用，可以用这两个替代用来处理简单的图形。</li>
<li>git:这个东西配合github，可以把其他各类代码放到github管理与同步，很方便。LaTeX文档(没错，论文也能)放上面。</li>
<li>pycharm: 写python代码用的。最近都用vim在写python代码，基本不怎么用了。</li>
</ul>
<p>下面是几个常用的工具：</p>
<ul>
<li><a href="https://convertio.co/zh/" target="_blank" rel="noopener">Convertio</a> 各种文件格式转换，写论文的时候用这个把图片转pdf,pdf转图片什么的。</li>
<li><a href="http://detexify.kirelabs.org/classify.html" target="_blank" rel="noopener">Detexify</a> LaTeX符合检测与转换。手画一个LaTeX符号，Detexify输出LaTeX代码，对那些都叫不出名字的符号，用这个比自己在列表里找方便多了</li>
<li><a href="http://linggle.com/" target="_blank" rel="noopener">Linggle</a> 写论文的时候时常纠结某个词用的对不对，这里是接to还是for，用a还是the还是不要。这些常用的搭配，用linggle的推荐基本就没错了，减少很多烦恼</li>
<li><a href="http://www.gingersoftware.com/" target="_blank" rel="noopener">Ginger</a> 身为中国人，对自己说的英语没自信，对自己写的英语也没自信。现在在国外访学，用这个工具来帮助检查自己的英语书写的语法错误，很方便。</li>
</ul>
<p>以后遇到其他给力的软件再放上来。</p>
]]></content>
      
        <categories>
            
            <category> ubuntu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> software </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
